
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>easy-1: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">leetcode-solutions/src/easy-1/solution.go (83.3%)</option>
				
				<option value="file1">leetcode-solutions/src/easy-100/solution.go (80.0%)</option>
				
				<option value="file2">leetcode-solutions/src/easy-101/solution.go (100.0%)</option>
				
				<option value="file3">leetcode-solutions/src/easy-104/solution.go (90.0%)</option>
				
				<option value="file4">leetcode-solutions/src/easy-108/solution.go (100.0%)</option>
				
				<option value="file5">leetcode-solutions/src/easy-110/solution.go (100.0%)</option>
				
				<option value="file6">leetcode-solutions/src/easy-111/iteration.go (87.5%)</option>
				
				<option value="file7">leetcode-solutions/src/easy-111/recursion.go (92.3%)</option>
				
				<option value="file8">leetcode-solutions/src/easy-112/solution.go (80.0%)</option>
				
				<option value="file9">leetcode-solutions/src/easy-1137/solution.go (87.5%)</option>
				
				<option value="file10">leetcode-solutions/src/easy-118/solution.go (100.0%)</option>
				
				<option value="file11">leetcode-solutions/src/easy-119/solution.go (100.0%)</option>
				
				<option value="file12">leetcode-solutions/src/easy-1290/solution.go (100.0%)</option>
				
				<option value="file13">leetcode-solutions/src/easy-136/solution.go (100.0%)</option>
				
				<option value="file14">leetcode-solutions/src/easy-14/solution.go (71.4%)</option>
				
				<option value="file15">leetcode-solutions/src/easy-141/solution.go (88.9%)</option>
				
				<option value="file16">leetcode-solutions/src/easy-160/solution.go (100.0%)</option>
				
				<option value="file17">leetcode-solutions/src/easy-167/solution.go (91.3%)</option>
				
				<option value="file18">leetcode-solutions/src/easy-169/solution.go (100.0%)</option>
				
				<option value="file19">leetcode-solutions/src/easy-191/solution.go (100.0%)</option>
				
				<option value="file20">leetcode-solutions/src/easy-20/solution.go (100.0%)</option>
				
				<option value="file21">leetcode-solutions/src/easy-203/solution.go (100.0%)</option>
				
				<option value="file22">leetcode-solutions/src/easy-206/solution.go (93.3%)</option>
				
				<option value="file23">leetcode-solutions/src/easy-21/solution.go (92.9%)</option>
				
				<option value="file24">leetcode-solutions/src/easy-217/solution.go (100.0%)</option>
				
				<option value="file25">leetcode-solutions/src/easy-226/solution.go (100.0%)</option>
				
				<option value="file26">leetcode-solutions/src/easy-234/solution.go (91.7%)</option>
				
				<option value="file27">leetcode-solutions/src/easy-235/solution.go (71.4%)</option>
				
				<option value="file28">leetcode-solutions/src/easy-242/solution.go (100.0%)</option>
				
				<option value="file29">leetcode-solutions/src/easy-257/solution.go (95.7%)</option>
				
				<option value="file30">leetcode-solutions/src/easy-26/solution.go (100.0%)</option>
				
				<option value="file31">leetcode-solutions/src/easy-263/solution.go (85.7%)</option>
				
				<option value="file32">leetcode-solutions/src/easy-344/solution.go (100.0%)</option>
				
				<option value="file33">leetcode-solutions/src/easy-349/solution.go (95.2%)</option>
				
				<option value="file34">leetcode-solutions/src/easy-35/solution.go (100.0%)</option>
				
				<option value="file35">leetcode-solutions/src/easy-350/solution.go (100.0%)</option>
				
				<option value="file36">leetcode-solutions/src/easy-387/solution.go (85.7%)</option>
				
				<option value="file37">leetcode-solutions/src/easy-404/solution.go (100.0%)</option>
				
				<option value="file38">leetcode-solutions/src/easy-415/solution.go (100.0%)</option>
				
				<option value="file39">leetcode-solutions/src/easy-509/solution.go (92.3%)</option>
				
				<option value="file40">leetcode-solutions/src/easy-53/solution.go (100.0%)</option>
				
				<option value="file41">leetcode-solutions/src/easy-530/solution.go (100.0%)</option>
				
				<option value="file42">leetcode-solutions/src/easy-538/solution.go (100.0%)</option>
				
				<option value="file43">leetcode-solutions/src/easy-557/solution.go (100.0%)</option>
				
				<option value="file44">leetcode-solutions/src/easy-559/solution.go (92.3%)</option>
				
				<option value="file45">leetcode-solutions/src/easy-617/solution.go (100.0%)</option>
				
				<option value="file46">leetcode-solutions/src/easy-637/solution.go (93.8%)</option>
				
				<option value="file47">leetcode-solutions/src/easy-657/solution.go (100.0%)</option>
				
				<option value="file48">leetcode-solutions/src/easy-70/solution.go (100.0%)</option>
				
				<option value="file49">leetcode-solutions/src/easy-700/solution.go (80.0%)</option>
				
				<option value="file50">leetcode-solutions/src/easy-704/solution.go (90.0%)</option>
				
				<option value="file51">leetcode-solutions/src/easy-771/solution.go (100.0%)</option>
				
				<option value="file52">leetcode-solutions/src/easy-783/solution.go (100.0%)</option>
				
				<option value="file53">leetcode-solutions/src/easy-83/solution.go (90.0%)</option>
				
				<option value="file54">leetcode-solutions/src/easy-88/solution.go (86.7%)</option>
				
				<option value="file55">leetcode-solutions/src/easy-9/solution.go (100.0%)</option>
				
				<option value="file56">leetcode-solutions/src/easy-925/solution.go (100.0%)</option>
				
				<option value="file57">leetcode-solutions/src/easy-941/solution.go (100.0%)</option>
				
				<option value="file58">leetcode-solutions/src/easy-977/solution.go (100.0%)</option>
				
				<option value="file59">leetcode-solutions/src/hard-135/solution.go (100.0%)</option>
				
				<option value="file60">leetcode-solutions/src/hard-154/solution.go (90.0%)</option>
				
				<option value="file61">leetcode-solutions/src/hard-25/solution.go (94.4%)</option>
				
				<option value="file62">leetcode-solutions/src/hard-76/solution.go (96.2%)</option>
				
				<option value="file63">leetcode-solutions/src/medium-103/solution.go (94.7%)</option>
				
				<option value="file64">leetcode-solutions/src/medium-1038/solution.go (36.4%)</option>
				
				<option value="file65">leetcode-solutions/src/medium-105/solution.go (100.0%)</option>
				
				<option value="file66">leetcode-solutions/src/medium-106/solution.go (100.0%)</option>
				
				<option value="file67">leetcode-solutions/src/medium-109/solution.go (100.0%)</option>
				
				<option value="file68">leetcode-solutions/src/medium-11/solution.go (100.0%)</option>
				
				<option value="file69">leetcode-solutions/src/medium-113/solution.go (100.0%)</option>
				
				<option value="file70">leetcode-solutions/src/medium-114/solution.go (93.8%)</option>
				
				<option value="file71">leetcode-solutions/src/medium-129/solution.go (96.3%)</option>
				
				<option value="file72">leetcode-solutions/src/medium-137/solution.go (100.0%)</option>
				
				<option value="file73">leetcode-solutions/src/medium-142/solution.go (92.3%)</option>
				
				<option value="file74">leetcode-solutions/src/medium-143/solution.go (93.8%)</option>
				
				<option value="file75">leetcode-solutions/src/medium-144/iteration.go (92.3%)</option>
				
				<option value="file76">leetcode-solutions/src/medium-147/solution.go (93.3%)</option>
				
				<option value="file77">leetcode-solutions/src/medium-15/solution.go (100.0%)</option>
				
				<option value="file78">leetcode-solutions/src/medium-153/solution.go (53.3%)</option>
				
				<option value="file79">leetcode-solutions/src/medium-16/solution.go (90.9%)</option>
				
				<option value="file80">leetcode-solutions/src/medium-1609/solution.go (92.3%)</option>
				
				<option value="file81">leetcode-solutions/src/medium-1637/solution.go (100.0%)</option>
				
				<option value="file82">leetcode-solutions/src/medium-1669/solution.go (100.0%)</option>
				
				<option value="file83">leetcode-solutions/src/medium-17/solution.go (100.0%)</option>
				
				<option value="file84">leetcode-solutions/src/medium-1721/solution.go (100.0%)</option>
				
				<option value="file85">leetcode-solutions/src/medium-18/solution.go (100.0%)</option>
				
				<option value="file86">leetcode-solutions/src/medium-189/solution.go (100.0%)</option>
				
				<option value="file87">leetcode-solutions/src/medium-19/solution.go (100.0%)</option>
				
				<option value="file88">leetcode-solutions/src/medium-2/solution.go (94.1%)</option>
				
				<option value="file89">leetcode-solutions/src/medium-208/array.go (89.5%)</option>
				
				<option value="file90">leetcode-solutions/src/medium-208/solution.go (90.0%)</option>
				
				<option value="file91">leetcode-solutions/src/medium-209/solution.go (100.0%)</option>
				
				<option value="file92">leetcode-solutions/src/medium-215/solution.go (100.0%)</option>
				
				<option value="file93">leetcode-solutions/src/medium-22/solution.go (100.0%)</option>
				
				<option value="file94">leetcode-solutions/src/medium-230/solution.go (85.7%)</option>
				
				<option value="file95">leetcode-solutions/src/medium-236/solution.go (63.6%)</option>
				
				<option value="file96">leetcode-solutions/src/medium-238/solution.go (100.0%)</option>
				
				<option value="file97">leetcode-solutions/src/medium-24/solution.go (92.3%)</option>
				
				<option value="file98">leetcode-solutions/src/medium-260/solution.go (91.7%)</option>
				
				<option value="file99">leetcode-solutions/src/medium-3/solution.go (100.0%)</option>
				
				<option value="file100">leetcode-solutions/src/medium-328/solution.go (91.7%)</option>
				
				<option value="file101">leetcode-solutions/src/medium-33/solution.go (100.0%)</option>
				
				<option value="file102">leetcode-solutions/src/medium-338/solution.go (100.0%)</option>
				
				<option value="file103">leetcode-solutions/src/medium-34/solution.go (100.0%)</option>
				
				<option value="file104">leetcode-solutions/src/medium-39/solution.go (100.0%)</option>
				
				<option value="file105">leetcode-solutions/src/medium-406/solution.go (100.0%)</option>
				
				<option value="file106">leetcode-solutions/src/medium-43/solution.go (96.6%)</option>
				
				<option value="file107">leetcode-solutions/src/medium-438/solution.go (100.0%)</option>
				
				<option value="file108">leetcode-solutions/src/medium-445/solution.go (96.2%)</option>
				
				<option value="file109">leetcode-solutions/src/medium-46/solution.go (100.0%)</option>
				
				<option value="file110">leetcode-solutions/src/medium-48/solution.go (100.0%)</option>
				
				<option value="file111">leetcode-solutions/src/medium-567/solution.go (100.0%)</option>
				
				<option value="file112">leetcode-solutions/src/medium-61/solution.go (93.3%)</option>
				
				<option value="file113">leetcode-solutions/src/medium-62/solution.go (100.0%)</option>
				
				<option value="file114">leetcode-solutions/src/medium-64/solution.go (100.0%)</option>
				
				<option value="file115">leetcode-solutions/src/medium-662/solution.go (95.0%)</option>
				
				<option value="file116">leetcode-solutions/src/medium-677/map.go (93.8%)</option>
				
				<option value="file117">leetcode-solutions/src/medium-701/solution.go (100.0%)</option>
				
				<option value="file118">leetcode-solutions/src/medium-707/solution.go (80.0%)</option>
				
				<option value="file119">leetcode-solutions/src/medium-75/solution.go (100.0%)</option>
				
				<option value="file120">leetcode-solutions/src/medium-767/solution.go (91.7%)</option>
				
				<option value="file121">leetcode-solutions/src/medium-78/solution.go (100.0%)</option>
				
				<option value="file122">leetcode-solutions/src/medium-81/solution.go (86.7%)</option>
				
				<option value="file123">leetcode-solutions/src/medium-82/solution.go (91.7%)</option>
				
				<option value="file124">leetcode-solutions/src/medium-86/solution.go (93.3%)</option>
				
				<option value="file125">leetcode-solutions/src/medium-889/solution.go (92.9%)</option>
				
				<option value="file126">leetcode-solutions/src/medium-90/solution.go (100.0%)</option>
				
				<option value="file127">leetcode-solutions/src/medium-912/solution.go (100.0%)</option>
				
				<option value="file128">leetcode-solutions/src/medium-92/solution.go (100.0%)</option>
				
				<option value="file129">leetcode-solutions/src/medium-94/iteration.go (93.3%)</option>
				
				<option value="file130">leetcode-solutions/src/medium-94/recursion.go (100.0%)</option>
				
				<option value="file131">leetcode-solutions/src/medium-96/solution.go (100.0%)</option>
				
				<option value="file132">leetcode-solutions/src/medium-973/solution.go (79.2%)</option>
				
				<option value="file133">leetcode-solutions/src/medium-98/iteration.go (100.0%)</option>
				
				<option value="file134">leetcode-solutions/src/medium-98/recursion.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package easy1

// TwoSum is used to solve two sum problem
func TwoSum(nums []int, target int) []int <span class="cov8" title="1">{
        numsMap := map[int]int{}

        for i := 0; i &lt; len(nums); i++ </span><span class="cov8" title="1">{
                if _, ok := numsMap[target-nums[i]]; ok </span><span class="cov8" title="1">{
                        return []int{numsMap[target-nums[i]], i}
                }</span>
                <span class="cov8" title="1">numsMap[nums[i]] = i</span>
        }

        <span class="cov0" title="0">return []int{}</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package easy100

import (
        structures "leetcode-solutions/data-structures"
)

type node = structures.BinaryTreeNode

func isSameTree(p, q *node) bool <span class="cov8" title="1">{
        if p == nil &amp;&amp; q == nil </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">if p == nil || q == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return p.Val == q.Val &amp;&amp; isSameTree(p.Left, q.Left) &amp;&amp; isSameTree(p.Right, q.Right)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package easy101

import (
        structures "leetcode-solutions/data-structures"
)

type node = structures.BinaryTreeNode

func isSymmetric(root *node) bool <span class="cov8" title="1">{
        var traversal func(a, b *node) bool
        traversal = func(a, b *node) bool </span><span class="cov8" title="1">{
                if a == nil &amp;&amp; b == nil </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov8" title="1">if a == nil || b == nil </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">return a.Val == b.Val &amp;&amp; traversal(a.Left, b.Right) &amp;&amp; traversal(a.Right, b.Left)</span>
        }
        <span class="cov8" title="1">return traversal(root, root)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package easy104

import (
        structures "leetcode-solutions/data-structures"
)

func maxDepth(root *structures.BinaryTreeNode) int <span class="cov8" title="1">{
        if root == nil </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return 1 + max(maxDepth(root.Left), maxDepth(root.Right))</span>
}

func max(a, b int) int <span class="cov8" title="1">{
        if a &gt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}

func maxDepthWithLevelOrder(root *structures.BinaryTreeNode) int <span class="cov8" title="1">{
        if root == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">queue, depth := []*structures.BinaryTreeNode{root}, 0

        for len(queue) &gt; 0 </span><span class="cov8" title="1">{
                levelSize := len(queue)
                depth++

                for i := 0; i &lt; levelSize; i++ </span><span class="cov8" title="1">{
                        current := queue[0]
                        queue = queue[1:]
                        if current.Left != nil </span><span class="cov8" title="1">{
                                queue = append(queue, current.Left)
                        }</span>
                        <span class="cov8" title="1">if current.Right != nil </span><span class="cov8" title="1">{
                                queue = append(queue, current.Right)
                        }</span>
                }
        }

        <span class="cov8" title="1">return depth</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package easy108

import (
        structures "leetcode-solutions/data-structures"
)

type node = structures.BinaryTreeNode

func sortedArrayToBST(nums []int) *node <span class="cov8" title="1">{
        var createTree func(nums []int, low int, high int) *node
        createTree = func(nums []int, low int, high int) *node </span><span class="cov8" title="1">{
                if low &gt; high </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">index := low + ((high - low) / 2)
                return &amp;node{
                        Val:   nums[index],
                        Left:  createTree(nums, low, index-1),
                        Right: createTree(nums, index+1, high),
                }</span>
        }
        <span class="cov8" title="1">return createTree(nums, 0, len(nums)-1)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package easy110

import (
        structures "leetcode-solutions/data-structures"
)

type node = structures.BinaryTreeNode

// based on top-to-bottom dfs
// func isBalanced(root *node) bool {
//         if root == nil {
//                 return true
//         }

//         return abs(height(root.Left)-height(root.Right)) &lt; 2 &amp;&amp; isBalanced(root.Left) &amp;&amp; isBalanced(root.Right)
// }

// func height(root *node) int {
//         if root == nil {
//                 return 0
//         }
//         return max(height(root.Left), height(root.Right)) + 1
// }

// based on bottom-to-top dfs
func isBalanced(root *node) bool <span class="cov8" title="1">{
        return height(root) &gt; 0
}</span>

func height(root *node) int <span class="cov8" title="1">{
        if root == nil </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">left := height(root.Left)
        if left == -1 </span><span class="cov8" title="1">{
                return -1
        }</span>
        <span class="cov8" title="1">right := height(root.Right)
        if right == -1 || abs(left-right) &gt; 1 </span><span class="cov8" title="1">{
                return -1
        }</span>

        <span class="cov8" title="1">return max(left, right) + 1</span>
}

func abs(a int) int <span class="cov8" title="1">{
        if a &lt; 0 </span><span class="cov8" title="1">{
                return a * -1
        }</span>
        <span class="cov8" title="1">return a</span>
}

func max(a, b int) int <span class="cov8" title="1">{
        if a &gt; b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package easy111

import (
        structures "leetcode-solutions/data-structures"
)

type node = structures.BinaryTreeNode

func iterativeMinDepth(root *node) int <span class="cov8" title="1">{
        if root == nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">queue, depth := []*node{root}, 0
        for len(queue) &gt; 0 </span><span class="cov8" title="1">{
                levelSize := len(queue)
                depth++
                for i := 0; i &lt; levelSize; i++ </span><span class="cov8" title="1">{
                        current := queue[0]
                        queue = queue[1:]
                        if current.Left == nil &amp;&amp; current.Right == nil </span><span class="cov8" title="1">{
                                return depth
                        }</span>
                        <span class="cov8" title="1">if current.Left != nil </span><span class="cov8" title="1">{
                                queue = append(queue, current.Left)
                        }</span>
                        <span class="cov8" title="1">if current.Right != nil </span><span class="cov8" title="1">{
                                queue = append(queue, current.Right)
                        }</span>
                }
        }

        <span class="cov0" title="0">return depth</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package easy111

import "math"

func recursiveMinDepth(root *node) int <span class="cov8" title="1">{
        if root == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">if root.Left == nil &amp;&amp; root.Right == nil </span><span class="cov8" title="1">{
                return 1
        }</span>
        <span class="cov8" title="1">depth := math.MaxInt32
        if root.Left != nil </span><span class="cov8" title="1">{
                depth = min(recursiveMinDepth(root.Left), depth)
        }</span>
        <span class="cov8" title="1">if root.Right != nil </span><span class="cov8" title="1">{
                depth = min(recursiveMinDepth(root.Right), depth)
        }</span>
        <span class="cov8" title="1">return depth + 1</span>
}

func min(a, b int) int <span class="cov8" title="1">{
        if a &gt; b </span><span class="cov8" title="1">{
                return b
        }</span>
        <span class="cov8" title="1">return a</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package easy112

import (
        structures "leetcode-solutions/data-structures"
)

type node = structures.BinaryTreeNode

func hasPathSum(root *node, sum int) bool <span class="cov8" title="1">{
        if root == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if root.Left == nil &amp;&amp; root.Right == nil </span><span class="cov8" title="1">{
                return sum-root.Val == 0
        }</span>

        <span class="cov8" title="1">return hasPathSum(root.Left, sum-root.Val) || hasPathSum(root.Right, sum-root.Val)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package easy1137

func tribonacci(n int) int <span class="cov8" title="1">{
        if n &lt; 2 </span><span class="cov0" title="0">{
                return n
        }</span>
        <span class="cov8" title="1">if n == 2 </span><span class="cov0" title="0">{
                return 1
        }</span>
        <span class="cov8" title="1">dp := make([]int, n+1)
        dp[0], dp[1], dp[2] = 0, 1, 1
        for i := 3; i &lt;= n; i++ </span><span class="cov8" title="1">{
                dp[i] = dp[i-1] + dp[i-2] + dp[i-3]
        }</span>
        <span class="cov8" title="1">return dp[n]</span>
}

func tribonacci0(n int) int <span class="cov8" title="1">{
        a, b, c := 0, 1, 1
        for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                next := a + b + c
                a = b
                b = c
                c = next
        }</span>
        <span class="cov8" title="1">return a</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package easy118

func generate(numRows int) [][]int <span class="cov8" title="1">{
        /*
                1. 第 i 行有 i + 1 项
                2. dp[i][j] = dp[i-1][j-1]+dp[i-1][j]
        */
        dp := make([][]int, numRows)
        for i := 0; i &lt; numRows; i++ </span><span class="cov8" title="1">{
                dp[i] = make([]int, i+1)
                dp[i][0] = 1
                dp[i][(i+1)-1] = 1
                for j := 1; j &lt; i; j++ </span><span class="cov8" title="1">{
                        dp[i][j] = dp[i-1][j-1] + dp[i-1][j]
                }</span>
        }
        <span class="cov8" title="1">return dp</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package easy119

/*
        解题核心思路同 118，不同之处在于通过滚动数组实现 DP 的空间复杂度优化
*/
func getRow(rowIndex int) []int <span class="cov8" title="1">{
        // 第 i 行有 i + 1 项
        row := make([]int, rowIndex+1)

        for i := 0; i &lt;= rowIndex; i++ </span><span class="cov8" title="1">{
                before := make([]int, rowIndex+1)
                copy(before, row)
                row[0] = 1
                row[i] = 1
                for j := 1; j &lt; i; j++ </span><span class="cov8" title="1">{
                        row[j] = before[j-1] + before[j]
                }</span>
        }
        <span class="cov8" title="1">return row</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package easy1290

import (
        structures "leetcode-solutions/data-structures"
)

type node = structures.LinkedListNode

func getDecimalValue(head *node) int <span class="cov8" title="1">{
        sum := 0
        for head != nil </span><span class="cov8" title="1">{
                sum = sum*2 + head.Val
                head = head.Next
        }</span>

        <span class="cov8" title="1">return sum</span>
}

func getDecimalValue0(head *node) int <span class="cov8" title="1">{
        sum := 0
        for head != nil </span><span class="cov8" title="1">{
                sum = (sum &lt;&lt; 1) + head.Val
                head = head.Next
        }</span>

        <span class="cov8" title="1">return sum</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package easy136

func singleNumber(nums []int) int <span class="cov8" title="1">{
        var ans int
        for _, num := range nums </span><span class="cov8" title="1">{
                ans ^= num
        }</span>
        <span class="cov8" title="1">return ans</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package easy14

func longestCommonPrefix(strs []string) string <span class="cov8" title="1">{
        if len(strs) &lt; 1 </span><span class="cov0" title="0">{
                return ``
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; len(strs[0]); i++ </span><span class="cov8" title="1">{
                for j := 1; j &lt; len(strs); j++ </span><span class="cov8" title="1">{
                        if i == len(strs[j]) || strs[j][i] != strs[0][i] </span><span class="cov8" title="1">{
                                return strs[0][:i]
                        }</span>
                }
        }

        <span class="cov0" title="0">return strs[0]</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package easy141

import structures "leetcode-solutions/data-structures"

type node = structures.LinkedListNode

func hasCycle(head *node) bool <span class="cov8" title="1">{
        if head == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">slow, fast := head, head
        for fast != nil &amp;&amp; fast.Next != nil </span><span class="cov8" title="1">{
                fast = fast.Next.Next
                slow = slow.Next
                if fast == slow </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package easy160

import structures "leetcode-solutions/data-structures"

type node = structures.LinkedListNode

func getIntersectionNode(headA, headB *node) *node <span class="cov8" title="1">{
        a, b := headA, headB
        for a != b </span><span class="cov8" title="1">{
                if a == nil </span><span class="cov8" title="1">{
                        a = headB
                }</span> else<span class="cov8" title="1"> {
                        a = a.Next
                }</span>
                <span class="cov8" title="1">if b == nil </span><span class="cov8" title="1">{
                        b = headA
                }</span> else<span class="cov8" title="1"> {
                        b = b.Next
                }</span>
        }
        <span class="cov8" title="1">return a</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package easy167

func twoSum(numbers []int, target int) []int <span class="cov8" title="1">{
        low, high := 0, len(numbers)-1

        for low &lt; high </span><span class="cov8" title="1">{
                left, right := numbers[low], numbers[high]
                sum := left + right
                if sum &gt; target </span><span class="cov8" title="1">{
                        for low &lt; high &amp;&amp; (numbers[high] == right) </span><span class="cov8" title="1">{
                                high--
                        }</span>
                } else<span class="cov8" title="1"> if sum &lt; target </span><span class="cov8" title="1">{
                        for low &lt; high &amp;&amp; (numbers[low] == left) </span><span class="cov8" title="1">{
                                low++
                        }</span>
                } else<span class="cov8" title="1"> {
                        return []int{low + 1, high + 1}
                }</span>
        }

        <span class="cov0" title="0">return []int{-1, -1}</span>
}

func twoSumWithBinary(numbers []int, target int) []int <span class="cov8" title="1">{
        for i := 0; i &lt; len(numbers); i++ </span><span class="cov8" title="1">{
                low, high := i+1, len(numbers)-1
                for low &lt;= high </span><span class="cov8" title="1">{
                        mid := low + (high-low)/2
                        sum := numbers[i] + numbers[mid]
                        if sum &gt; target </span><span class="cov8" title="1">{
                                high = mid - 1
                        }</span> else<span class="cov8" title="1"> if sum &lt; target </span><span class="cov8" title="1">{
                                low = mid + 1
                        }</span> else<span class="cov8" title="1"> {
                                return []int{i + 1, mid + 1}
                        }</span>
                }
        }

        <span class="cov0" title="0">return []int{-1, -1}</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package easy169

import "sort"

func majorityElement(nums []int) int <span class="cov8" title="1">{
        sort.Ints(nums)
        return nums[len(nums)&gt;&gt;1]
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package easy191

func hammingWeight(num uint32) int <span class="cov8" title="1">{
        var ans int
        for num &gt; 0 </span><span class="cov8" title="1">{
                num &amp;= (num - 1)
                ans++
        }</span>
        <span class="cov8" title="1">return ans</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package easy20

func isValid(s string) bool <span class="cov8" title="1">{
        charMap := map[rune]rune{
                ')': '(',
                ']': '[',
                '}': '{',
        }
        stack := []rune{}

        for _, char := range s </span><span class="cov8" title="1">{
                if len(stack) &gt; 0 &amp;&amp; charMap[char] == stack[len(stack)-1] </span><span class="cov8" title="1">{
                        stack = stack[:len(stack)-1]
                }</span> else<span class="cov8" title="1"> {
                        stack = append(stack, char)
                }</span>
        }

        <span class="cov8" title="1">return len(stack) &lt; 1</span>
}

func isValid0(s string) bool <span class="cov8" title="1">{
        charMap := map[rune]rune{
                '(': ')',
                '[': ']',
                '{': '}',
        }

        var stack []rune
        for _, r := range s </span><span class="cov8" title="1">{
                // 如果是开始的括号时，加入到栈中，待匹配
                if _, ok := charMap[r]; ok </span><span class="cov8" title="1">{
                        stack = append(stack, r)
                        continue</span>
                }

                // 没有待匹配括号时，但需要匹配时，则不满足题目要求，退出执行
                <span class="cov8" title="1">if len(stack) &lt; 1 </span><span class="cov8" title="1">{
                        return false
                }</span>

                // 否则取栈顶待匹配括号来匹配当前括号
                <span class="cov8" title="1">topIndex := len(stack) - 1
                top := stack[topIndex]
                if charMap[top] == r </span><span class="cov8" title="1">{
                        stack = stack[:topIndex]
                        continue</span>
                }

                // 当栈顶括号无法匹配时，即不满足题目要求
                <span class="cov8" title="1">return false</span>
        }
        <span class="cov8" title="1">return len(stack) == 0</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package easy203

import (
        structures "leetcode-solutions/data-structures"
)

type node = structures.LinkedListNode

func removeElement(head *node, val int) *node <span class="cov8" title="1">{
        sentinel := &amp;node{Val: -1, Next: head}
        prev := sentinel
        current := sentinel.Next

        for current != nil </span><span class="cov8" title="1">{
                if current.Val == val </span><span class="cov8" title="1">{
                        prev.Next = current.Next
                }</span> else<span class="cov8" title="1"> {
                        prev = current
                }</span>
                <span class="cov8" title="1">current = current.Next</span>
        }

        <span class="cov8" title="1">return sentinel.Next</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package easy206

import (
        structures "leetcode-solutions/data-structures"
)

type node = structures.LinkedListNode

func reverseListIteration(head *node) *node <span class="cov8" title="1">{
        if head == nil </span><span class="cov0" title="0">{
                return head
        }</span>

        <span class="cov8" title="1">sentinel := &amp;node{Next: head}

        for head.Next != nil </span><span class="cov8" title="1">{
                next := head.Next
                head.Next = head.Next.Next
                next.Next = sentinel.Next
                sentinel.Next = next
        }</span>

        <span class="cov8" title="1">return sentinel.Next</span>
}

func reverseListRecursion(head *node) *node <span class="cov8" title="1">{
        if head == nil || head.Next == nil </span><span class="cov8" title="1">{
                return head
        }</span>

        <span class="cov8" title="1">tail := reverseListRecursion(head.Next)
        head.Next.Next = head
        head.Next = nil
        return tail</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package easy21

import structures "leetcode-solutions/data-structures"

type list = structures.LinkedListNode

func mergeTwoList(l1, l2 *list) *list <span class="cov8" title="1">{
        current1, current2 := l1, l2
        sentinel := &amp;list{}
        current := sentinel

        for current1 != nil &amp;&amp; current2 != nil </span><span class="cov8" title="1">{
                if current1.Val &gt; current2.Val </span><span class="cov8" title="1">{
                        current.Next = current2
                        current2 = current2.Next
                }</span> else<span class="cov8" title="1"> {
                        current.Next = current1
                        current1 = current1.Next
                }</span>
                <span class="cov8" title="1">current = current.Next</span>
        }

        // 将未完成合并的链表部分直接合并
        <span class="cov8" title="1">if current1 == nil </span><span class="cov8" title="1">{
                current.Next = current2
        }</span> else<span class="cov0" title="0"> {
                current.Next = current1
        }</span>

        <span class="cov8" title="1">return sentinel.Next</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package easy217

func containsDuplicate(nums []int) bool <span class="cov8" title="1">{
        items := map[int]int{}

        for _, num := range nums </span><span class="cov8" title="1">{
                if items[num] &gt; 0 </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov8" title="1">items[num]++</span>
        }

        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package easy226

import (
        structures "leetcode-solutions/data-structures"
)

type node = structures.BinaryTreeNode

func invertTree(root *node) *node <span class="cov8" title="1">{
        if root == nil </span><span class="cov8" title="1">{
                return root
        }</span>
        <span class="cov8" title="1">invertTree(root.Left)
        invertTree(root.Right)
        root.Left, root.Right = root.Right, root.Left
        return root</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package easy234

import (
        structures "leetcode-solutions/data-structures"
)

type node = structures.LinkedListNode

func isPalindrome(head *node) bool <span class="cov8" title="1">{
        if head == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">slow, fast := head, head
        for fast != nil &amp;&amp; fast.Next != nil </span><span class="cov8" title="1">{
                fast = fast.Next.Next
                slow = slow.Next
        }</span>

        <span class="cov8" title="1">if fast != nil </span><span class="cov0" title="0">{
                slow = slow.Next
        }</span>

        <span class="cov8" title="1">left, right := head, reverseList(slow)

        for right != nil </span><span class="cov8" title="1">{
                if right.Val != left.Val </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">left = left.Next
                right = right.Next</span>
        }

        <span class="cov8" title="1">return true</span>
}

func reverseList(head *node) *node <span class="cov8" title="1">{
        if head == nil </span><span class="cov0" title="0">{
                return head
        }</span>

        <span class="cov8" title="1">sentinel := &amp;node{Next: head}
        for head.Next != nil </span><span class="cov8" title="1">{
                next := head.Next
                head.Next = head.Next.Next
                next.Next = sentinel.Next
                sentinel.Next = next
        }</span>

        <span class="cov8" title="1">return sentinel.Next</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package easy235

import (
        structures "leetcode-solutions/data-structures"
)

type node = structures.BinaryTreeNode

func lowestCommonAncestor(root, p, q *node) (ancestor *node) <span class="cov8" title="1">{
        ancestor = root
        for </span><span class="cov8" title="1">{
                if p.Val &lt; ancestor.Val &amp;&amp; p.Val &gt; ancestor.Val </span><span class="cov0" title="0">{
                        ancestor = ancestor.Left
                }</span> else<span class="cov8" title="1"> if p.Val &gt; ancestor.Val &amp;&amp; q.Val &gt; ancestor.Val </span><span class="cov0" title="0">{
                        ancestor = ancestor.Right
                }</span> else<span class="cov8" title="1"> {
                        return
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package easy242

// IsAnagram is used to judge anagram
func IsAnagram(s, t string) bool <span class="cov8" title="1">{
        if len(s) != len(t) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">charCodeMap := map[byte]int{}
        for i := 0; i &lt; len(s); i++ </span><span class="cov8" title="1">{
                charCodeMap[s[i]]++
                charCodeMap[t[i]]--
        }</span>
        <span class="cov8" title="1">for charCode := range charCodeMap </span><span class="cov8" title="1">{
                if charCodeMap[charCode] != 0 </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package easy257

import (
        structures "leetcode-solutions/data-structures"
        "strconv"
        "strings"
)

type node = structures.BinaryTreeNode

func binaryTreePaths(root *node) (paths []string) <span class="cov8" title="1">{
        createPath(root, "", &amp;paths)
        return
}</span>

func createPath(root *node, path string, paths *[]string) <span class="cov8" title="1">{
        if root == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">path += strconv.Itoa(root.Val)
        if root.Left == nil &amp;&amp; root.Right == nil </span><span class="cov8" title="1">{
                *paths = append(*paths, path)
        }</span> else<span class="cov8" title="1"> {
                path += "-&gt;"
                createPath(root.Left, path, paths)
                createPath(root.Right, path, paths)
        }</span>
}

func binaryTreePaths0(root *node) (paths []string) <span class="cov8" title="1">{
        if root == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">var dfs func(root *node, path []string)
        dfs = func(root *node, path []string) </span><span class="cov8" title="1">{
                if root == nil </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">path = append(path, strconv.Itoa(root.Val))
                if root.Left == nil &amp;&amp; root.Right == nil </span><span class="cov8" title="1">{
                        paths = append(paths, strings.Join(path, "-&gt;"))
                }</span>
                <span class="cov8" title="1">dfs(root.Left, path)
                dfs(root.Right, path)</span>
        }
        <span class="cov8" title="1">dfs(root, []string{})
        return</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package easy26

func removeDuplicated(nums []int) int <span class="cov8" title="1">{
        slow, fast := 0, 0
        for fast &lt; len(nums) </span><span class="cov8" title="1">{
                if nums[slow] != nums[fast] </span><span class="cov8" title="1">{
                        slow++
                        nums[slow] = nums[fast]
                }</span>
                <span class="cov8" title="1">fast++</span>
        }
        <span class="cov8" title="1">return slow + 1</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package easy263

func isUgly(n int) bool <span class="cov8" title="1">{
        if n &lt;= 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">factors := []int{2, 3, 5}
        for _, factor := range factors </span><span class="cov8" title="1">{
                for n%factor == 0 </span><span class="cov8" title="1">{
                        n /= factor
                }</span>
        }

        <span class="cov8" title="1">return n == 1</span>
}

// 法二；最小堆
// 法三：动态规划
</pre>
		
		<pre class="file" id="file32" style="display: none">package easy344

func reverseString(s []byte) <span class="cov8" title="1">{
        low, high := 0, len(s)-1
        for low &lt; high </span><span class="cov8" title="1">{
                s[low], s[high] = s[high], s[low]
                low++
                high--
        }</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package easy349

import (
        "sort"
)

/*
        左右指针移动的依据是： 在 **有序** 序列中，当 a[i] &gt; b[j] 时，移动 b 序列的 j 指针，以使得 b[j] 的值尽可能靠近 a[i] 的值，进而才会有 a[i] == b[j] 的可能性，进而得到交集
*/
func intersection(nums1 []int, nums2 []int) (ans []int) <span class="cov8" title="1">{
        sort.Ints(nums1)
        sort.Ints(nums2)
        len1, len2 := len(nums1), len(nums2)
        i, j := 0, 0

        var isIncluded func([]int, int) bool
        isIncluded = func(nums []int, num int) bool </span><span class="cov8" title="1">{
                for _, val := range nums </span><span class="cov8" title="1">{
                        if val == num </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
                <span class="cov8" title="1">return false</span>
        }

        <span class="cov8" title="1">for i &lt; len1 &amp;&amp; j &lt; len2 </span><span class="cov8" title="1">{
                current1, current2 := nums1[i], nums2[j]
                if current1 == current2 </span><span class="cov8" title="1">{
                        if !isIncluded(ans, current1) </span><span class="cov8" title="1">{
                                ans = append(ans, current1)
                        }</span>
                        <span class="cov8" title="1">i++
                        j++</span>
                } else<span class="cov8" title="1"> if current1 &gt; current2 </span><span class="cov0" title="0">{
                        j++
                }</span> else<span class="cov8" title="1"> {
                        i++
                }</span>
        }
        <span class="cov8" title="1">return ans</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package easy35

// time complexity O(logN), space complexity O(1)
func SearchInsert(nums []int, target int) int <span class="cov8" title="1">{
        left, right := 0, len(nums)-1

        if nums[right] &lt; target </span><span class="cov8" title="1">{
                return right + 1
        }</span>

        <span class="cov8" title="1">for left &lt; right </span><span class="cov8" title="1">{
                pivotIndex := left + ((right - left) &gt;&gt; 1)
                pivot := nums[pivotIndex]

                // 始终要保证所有的 if 语句无交集，且并集一定是 [left, right] 区间
                if pivot &lt; target </span><span class="cov8" title="1">{
                        left = pivotIndex + 1 // [pivotIndex + 1, right]
                }</span> else<span class="cov8" title="1"> {
                        right = pivotIndex // [left, pivotIndex]
                }</span>
        }

        <span class="cov8" title="1">return left</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package easy350

import "sort"

// TwoPointers based on sorted slice
func TwoPointers(nums1, nums2 []int) []int <span class="cov8" title="1">{
        sort.Ints(nums1)
        sort.Ints(nums2)
        length1, length2 := len(nums1), len(nums2)
        i, j := 0, 0
        answer := []int{}

        for i &lt; length1 &amp;&amp; j &lt; length2 </span><span class="cov8" title="1">{
                if nums1[i] == nums2[j] </span><span class="cov8" title="1">{
                        answer = append(answer, nums1[i])
                        i++
                        j++
                }</span> else<span class="cov8" title="1"> if nums1[i] &lt; nums2[j] </span><span class="cov8" title="1">{
                        i++
                }</span> else<span class="cov8" title="1"> if nums1[i] &gt; nums2[j] </span><span class="cov8" title="1">{
                        j++
                }</span>
        }

        <span class="cov8" title="1">return answer</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package easy367

func firstUniqChar(s string) int <span class="cov8" title="1">{
        chars := make(map[rune]int)
        for _, ch := range s </span><span class="cov8" title="1">{
                chars[ch]++
        }</span>

        <span class="cov8" title="1">for i, ch := range s </span><span class="cov8" title="1">{
                if chars[ch] == 1 </span><span class="cov8" title="1">{
                        return i
                }</span>
        }
        <span class="cov0" title="0">return -1</span>
}

func firstUniqCharFromSlice(s string) int <span class="cov8" title="1">{
        chars := make([]int, 26)
        for _, ch := range s </span><span class="cov8" title="1">{
                chars[ch-'a']++
        }</span>

        <span class="cov8" title="1">for i, ch := range s </span><span class="cov8" title="1">{
                if chars[ch-'a'] == 1 </span><span class="cov8" title="1">{
                        return i
                }</span>
        }

        <span class="cov0" title="0">return -1</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package easy404

import (
        structures "leetcode-solutions/data-structures"
)

type node = structures.BinaryTreeNode

func sumOfLeftLeaves(root *node) int <span class="cov8" title="1">{
        var sum int
        if root == nil </span><span class="cov8" title="1">{
                return sum
        }</span>
        <span class="cov8" title="1">if root.Left != nil &amp;&amp; root.Left.Left == nil &amp;&amp; root.Left.Right == nil </span><span class="cov8" title="1">{
                sum += root.Left.Val
        }</span>
        <span class="cov8" title="1">return sum + sumOfLeftLeaves(root.Left) + sumOfLeftLeaves(root.Right)</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package easy415

import "strconv"

func addStrings(num1, num2 string) string <span class="cov8" title="1">{
        add, answer := 0, ""

        for i, j := len(num1)-1, len(num2)-1; i &gt;= 0 || j &gt;= 0 || add != 0; i, j = i-1, j-1 </span><span class="cov8" title="1">{
                var x, y int
                if i &gt;= 0 </span><span class="cov8" title="1">{
                        x = int(num1[i] - '0') // '0' 为 rune 类型(alias for int32)
                }</span>
                <span class="cov8" title="1">if j &gt;= 0 </span><span class="cov8" title="1">{
                        y = int(num2[j] - '0')
                }</span>
                <span class="cov8" title="1">result := x + y + add
                answer = strconv.Itoa(result%10) + answer
                add = result / 10</span>
        }

        <span class="cov8" title="1">return answer</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package easy509

func fib(n int) int <span class="cov8" title="1">{
        if n &lt; 2 </span><span class="cov0" title="0">{
                return n
        }</span>
        <span class="cov8" title="1">dp := make([]int, n+1)
        dp[0], dp[1] = 0, 1
        for i := 2; i &lt;= n; i++ </span><span class="cov8" title="1">{
                dp[i] = dp[i-1] + dp[i-2]
        }</span>
        <span class="cov8" title="1">return dp[n]</span>
}

func fib0(n int) int <span class="cov8" title="1">{
        a, b := 0, 1
        for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                next := a + b
                a = b
                b = next
        }</span>
        <span class="cov8" title="1">return a</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package easy53

func maxSubArray(nums []int) int <span class="cov8" title="1">{
        prev, ans := 0, nums[0]
        var max func(a, b int) int = func(a, b int) int </span><span class="cov8" title="1">{
                if a &gt; b </span><span class="cov8" title="1">{
                        return a
                }</span>
                <span class="cov8" title="1">return b</span>
        }

        <span class="cov8" title="1">for _, num := range nums </span><span class="cov8" title="1">{
                // 此处比较的是 f(i-1) 动态规划的结果，并非 0 ~ i-1 的整个序列和。因为我们根据动态规划，始终可以认为 f(i) = max(f(i-1) + nums[i], nums[i])
                // 前面累加是否有自己大，有则加进去，反之，直接从自己开始重新计和
                prev = max(prev+num, num)
                ans = max(prev, ans)
        }</span>

        <span class="cov8" title="1">return ans</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package easy530

import (
        structures "leetcode-solutions/data-structures"
        "math"
)

type node = structures.BinaryTreeNode

func getMinimumDifference(root *node) int <span class="cov8" title="1">{
        answer, prev := math.MaxInt64, -1
        var dfs func(root *node)
        dfs = func(root *node) </span><span class="cov8" title="1">{
                if root == nil </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">dfs(root.Left)
                if prev != -1 &amp;&amp; (root.Val-prev &lt; answer) </span><span class="cov8" title="1">{
                        answer = root.Val - prev
                }</span>
                <span class="cov8" title="1">prev = root.Val
                dfs(root.Right)</span>
        }
        <span class="cov8" title="1">dfs(root)
        return answer</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package easy538

import (
        structures "leetcode-solutions/data-structures"
)

type node = structures.BinaryTreeNode

func convertBST(root *node) *node <span class="cov8" title="1">{
        var prev int
        var dfs func(root *node) *node
        dfs = func(root *node) *node </span><span class="cov8" title="1">{
                if root == nil </span><span class="cov8" title="1">{
                        return root
                }</span>
                <span class="cov8" title="1">dfs(root.Right)
                prev += root.Val
                root.Val = prev
                dfs(root.Left)
                return root</span>
        }
        <span class="cov8" title="1">return dfs(root)</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package easy557

import "strings"

func reverseWords(s string) string <span class="cov8" title="1">{
        words := strings.Split(s, " ")

        var reverseWord func(string) string
        reverseWord = func(s string) (ans string) </span><span class="cov8" title="1">{
                for i := len(s) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                        ans += string(s[i])
                }</span>
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">var ans string
        for i, word := range words </span><span class="cov8" title="1">{
                ans += reverseWord(word)
                if i &lt; len(words)-1 </span><span class="cov8" title="1">{
                        ans += " "
                }</span>
        }

        <span class="cov8" title="1">return ans</span>
}

func reverseWords1(s string) string <span class="cov8" title="1">{
        words := strings.Split(s, " ")

        var reverseWord func(string) string
        reverseWord = func(s string) (ans string) </span><span class="cov8" title="1">{
                for i := len(s) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                        ans += string(s[i])
                }</span>
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">var ans []string
        for _, word := range words </span><span class="cov8" title="1">{
                ans = append(ans, reverseWord(word))
        }</span>

        // strings.Join has better performance than string addition operator.
        <span class="cov8" title="1">return strings.Join(ans, " ")</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package easy559

type node struct {
        Val      int
        Children []*node
}

func maxDepthBfs(root *node) (depth int) <span class="cov8" title="1">{
        if root == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">queue := []*node{root}
        for len(queue) &gt; 0 </span><span class="cov8" title="1">{
                levelSize := len(queue)
                depth++
                for i := 0; i &lt; levelSize; i++ </span><span class="cov8" title="1">{
                        current := queue[0]
                        queue = queue[1:]

                        if len(current.Children) &gt; 0 </span><span class="cov8" title="1">{
                                queue = append(queue, current.Children...)
                        }</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

func maxDepthDfs(root *node) int <span class="cov8" title="1">{
        var max func(int, int) int
        var dfs func(*node) int
        max = func(a, b int) int </span><span class="cov8" title="1">{
                if a &gt; b </span><span class="cov8" title="1">{
                        return a
                }</span>
                <span class="cov8" title="1">return b</span>
        }
        <span class="cov8" title="1">dfs = func(root *node) int </span><span class="cov8" title="1">{
                if root == nil </span><span class="cov0" title="0">{
                        return 0
                }</span>
                <span class="cov8" title="1">var depth int
                for _, child := range root.Children </span><span class="cov8" title="1">{
                        depth = max(depth, dfs(child))
                }</span>
                <span class="cov8" title="1">return depth + 1</span>
        }
        <span class="cov8" title="1">return dfs(root)</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package easy617

import (
        structures "leetcode-solutions/data-structures"
)

type node = structures.BinaryTreeNode

func mergeTrees(t1 *node, t2 *node) *node <span class="cov8" title="1">{
        if t1 == nil </span><span class="cov8" title="1">{
                return t2
        }</span>
        <span class="cov8" title="1">if t2 == nil </span><span class="cov8" title="1">{
                return t1
        }</span>
        <span class="cov8" title="1">treeNode := &amp;node{Val: t1.Val + t2.Val}
        treeNode.Left = mergeTrees(t1.Left, t2.Left)
        treeNode.Right = mergeTrees(t1.Right, t2.Right)
        return treeNode</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package easy637

import (
        structures "leetcode-solutions/data-structures"
)

type node = structures.BinaryTreeNode

func averageOfLevels(root *node) (answer []float64) <span class="cov8" title="1">{
        if root == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">queue := []*node{root}
        for len(queue) &gt; 0 </span><span class="cov8" title="1">{
                levelSize := len(queue)
                levelSum := 0
                for i := 0; i &lt; levelSize; i++ </span><span class="cov8" title="1">{
                        current := queue[0]
                        queue = queue[1:]
                        levelSum += current.Val
                        if current.Left != nil </span><span class="cov8" title="1">{
                                queue = append(queue, current.Left)
                        }</span>
                        <span class="cov8" title="1">if current.Right != nil </span><span class="cov8" title="1">{
                                queue = append(queue, current.Right)
                        }</span>
                }
                <span class="cov8" title="1">answer = append(answer, float64(levelSum)/float64(levelSize))</span>
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package easy657

// 关键在于量化机器人的执行步骤
func judgeCircle(moves string) bool <span class="cov8" title="1">{
        horizontal, vertical := 0, 0
        for _, move := range moves </span><span class="cov8" title="1">{
                switch move </span>{
                case 'U':<span class="cov8" title="1">
                        vertical++</span>
                case 'D':<span class="cov8" title="1">
                        vertical--</span>
                case 'L':<span class="cov8" title="1">
                        horizontal++</span>
                case 'R':<span class="cov8" title="1">
                        horizontal--</span>
                }
        }
        <span class="cov8" title="1">return (horizontal == 0) &amp;&amp; (vertical == 0)</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package easy70

func climbStairs(n int) int <span class="cov8" title="1">{
        prevPrev, prev, current := 0, 0, 1
        for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                prevPrev = prev
                prev = current
                current = prevPrev + prev
        }</span>
        <span class="cov8" title="1">return current</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package easy700

import structures "leetcode-solutions/data-structures"

type node = structures.BinaryTreeNode

// 因为是 BST 故借鉴其左子树各个节点小于根节点，右子树反之的特性，而使用二分法得到目标子树
func searchBST(root *node, val int) *node <span class="cov8" title="1">{
        if root == nil || (root.Val == val) </span><span class="cov8" title="1">{
                return root
        }</span>

        <span class="cov8" title="1">if root.Val &lt; val </span><span class="cov0" title="0">{
                return searchBST(root.Right, val)
        }</span>
        <span class="cov8" title="1">return searchBST(root.Left, val)</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package easy704

func search(nums []int, target int) int <span class="cov8" title="1">{
        low, high := 0, len(nums)-1

        for low &lt;= high </span><span class="cov8" title="1">{
                mid := low + ((high - low) &gt;&gt; 1)
                current := nums[mid]

                if current &gt; target </span><span class="cov0" title="0">{
                        high = mid - 1
                }</span> else<span class="cov8" title="1"> if current &lt; target </span><span class="cov8" title="1">{
                        low = mid + 1
                }</span> else<span class="cov8" title="1"> {
                        return mid
                }</span>
        }

        <span class="cov8" title="1">return -1</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package easy771

func numJewelsInStones(jewels, stones string) (sum int) <span class="cov8" title="1">{
        kinds := make(map[rune]int)
        for _, jewel := range jewels </span><span class="cov8" title="1">{
                kinds[jewel]++
        }</span>
        <span class="cov8" title="1">for _, stone := range stones </span><span class="cov8" title="1">{
                if _, ok := kinds[stone]; ok </span><span class="cov8" title="1">{
                        sum++
                }</span>
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package easy783

import (
        structures "leetcode-solutions/data-structures"
        "math"
)

type node = structures.BinaryTreeNode

func minDiffInBST(root *node) int <span class="cov8" title="1">{
        ans, prev := math.MaxInt64, -1
        var dfs func(root *node)
        dfs = func(root *node) </span><span class="cov8" title="1">{
                if root == nil </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">dfs(root.Left)
                if prev != -1 &amp;&amp; (root.Val-prev &lt; ans) </span><span class="cov8" title="1">{
                        ans = root.Val - prev
                }</span>
                <span class="cov8" title="1">prev = root.Val
                dfs(root.Right)</span>
        }
        <span class="cov8" title="1">dfs(root)
        return ans</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package easy83

import (
        structures "leetcode-solutions/data-structures"
)

func deleteDuplicated(head *structures.LinkedListNode) *structures.LinkedListNode <span class="cov8" title="1">{
        if head == nil </span><span class="cov0" title="0">{
                return head
        }</span>

        <span class="cov8" title="1">slow, fast := head, head.Next

        for fast != nil </span><span class="cov8" title="1">{
                if slow.Val != fast.Val </span><span class="cov8" title="1">{
                        slow.Next = fast
                        slow = slow.Next
                }</span>
                <span class="cov8" title="1">fast = fast.Next</span>
        }

        <span class="cov8" title="1">slow.Next = nil

        return head</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package easy88

func merge(nums1 []int, m int, nums2 []int, n int) <span class="cov8" title="1">{
        p, q, tail := m-1, n-1, m+n-1
        for ; p &gt;= 0 || q &gt;= 0; tail-- </span><span class="cov8" title="1">{
                var current int
                if p == -1 </span><span class="cov0" title="0">{
                        current = nums2[q]
                        q--
                }</span> else<span class="cov8" title="1"> if q == -1 </span><span class="cov8" title="1">{
                        current = nums1[p]
                        p--
                }</span> else<span class="cov8" title="1"> if nums1[p] &gt; nums2[q] </span><span class="cov8" title="1">{
                        // 因为是由后向前插入，故此处选择较大值
                        current = nums1[p]
                        p--
                }</span> else<span class="cov8" title="1"> {
                        current = nums2[q]
                        q--
                }</span>

                <span class="cov8" title="1">nums1[tail] = current</span>
        }
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package easy9

import "strconv"

func isPalindrome(x int) bool <span class="cov8" title="1">{
        if x &lt; 0 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">chars := strconv.Itoa(x)
        length := len(chars)
        for i := 0; i &lt; length; i++ </span><span class="cov8" title="1">{
                if chars[i] != chars[length-1-i] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package easy925

func isLongPressedName(name string, typed string) bool <span class="cov8" title="1">{
        i, j := 0, 0
        // 在 name 和 typed 上移动两指针
        for j &lt; len(typed) </span><span class="cov8" title="1">{
                // 正常匹配时，共进
                if i &lt; len(name) &amp;&amp; name[i] == typed[j] </span><span class="cov8" title="1">{
                        i++
                        j++
                        // 否则，存在重复输入时，输入指针前进至非重复字符
                }</span> else<span class="cov8" title="1"> if j &gt; 0 &amp;&amp; (typed[j] == typed[j-1]) </span><span class="cov8" title="1">{
                        j++
                        // 既不匹配，而且不是重复字符时，那么不符合要求
                }</span> else<span class="cov8" title="1"> {
                        return false
                }</span>
        }
        <span class="cov8" title="1">return i == len(name)</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package easy941

func validMuntainArray(A []int) bool <span class="cov8" title="1">{
        i, n := 0, len(A)

        for i+1 &lt; n &amp;&amp; A[i] &lt; A[i+1] </span><span class="cov8" title="1">{
                i++
        }</span>

        <span class="cov8" title="1">if i == 0 || i == n-1 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for i+1 &lt; n &amp;&amp; A[i] &gt; A[i+1] </span><span class="cov8" title="1">{
                i++
        }</span>

        <span class="cov8" title="1">return i == n-1</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package easy977

func sortedSqares(a []int) []int <span class="cov8" title="1">{
        left, right := 0, len(a)-1
        ans := make([]int, len(a))
        for i := len(a) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                low, high := a[left]*a[left], a[right]*a[right]
                if low &gt; high </span><span class="cov8" title="1">{
                        ans[i] = low
                        left++
                }</span> else<span class="cov8" title="1"> {
                        ans[i] = high
                        right--
                }</span>
        }
        <span class="cov8" title="1">return ans</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package hard135

func candy(ratings []int) (ans int) <span class="cov8" title="1">{
        var max func(int, int) int
        max = func(a, b int) int </span><span class="cov8" title="1">{
                if a &gt; b </span><span class="cov8" title="1">{
                        return a
                }</span>
                <span class="cov8" title="1">return b</span>
        }

        <span class="cov8" title="1">n := len(ratings)
        fromStart := make([]int, n)
        for i, rate := range ratings </span><span class="cov8" title="1">{
                if i &gt; 0 &amp;&amp; rate &gt; ratings[i-1] </span><span class="cov8" title="1">{
                        fromStart[i] = fromStart[i-1] + 1
                }</span> else<span class="cov8" title="1"> {
                        fromStart[i] = 1
                }</span>
        }

        <span class="cov8" title="1">right := 0
        for i := n - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                if i &lt; n-1 &amp;&amp; ratings[i] &gt; ratings[i+1] </span><span class="cov8" title="1">{
                        right++
                }</span> else<span class="cov8" title="1"> {
                        right = 1
                }</span>
                <span class="cov8" title="1">ans += max(fromStart[i], right)</span>
        }

        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package hard154

func findMin(nums []int) int <span class="cov8" title="1">{
        low, high := 0, len(nums)-1
        for low &lt; high </span><span class="cov8" title="1">{
                index := low + (high-low)/2
                pivot := nums[index]

                /*
                        推荐按以下 url 中的图片综合理解
                        @see https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/solution/xun-zhao-xuan-zhuan-pai-xu-shu-zu-zhong-de-zui--16/
                        原本数组是升序排列，那么旋转后的首项在原位置大于旋转后的末项。如：
                        前 ： 1 2 3 4 5 6 7
                        后 ： 4 5 6 7 1 2 3
                        由上可见，before[2] &lt; before[3], after[7] &lt; after[0]
                */
                // 当基准项小于末项时，表示旋转点（即最小项）在 pivot+1 ~ high 之间，因为末项不会为最小项，而基准项大于末项，所以 low 指针最大可移动到 pivot+1 项，而不仅仅是 pivot 项
                if pivot &gt; nums[high] </span><span class="cov8" title="1">{
                        low = index + 1
                        // 当基准项小于末项时，此时基准项可能为最小项，且最小项肯定不在 pivot ~ high 之间，那么移动 high 到基准项索引
                }</span> else<span class="cov8" title="1"> if pivot &lt; nums[high] </span><span class="cov8" title="1">{
                        high = index
                }</span> else<span class="cov0" title="0"> {
                        // 当基准项等于末项时，表示 pivot 到 high 之间存在重复项，且存在旋转点（最小值）
                        high--
                }</span>
        }
        // 指针碰撞时，即为旋转点，即为最小值
        <span class="cov8" title="1">return nums[low]</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package hard25

import (
        structures "leetcode-solutions/data-structures"
)

type node = structures.LinkedListNode

func reverseKgroup(head *node, k int) *node <span class="cov8" title="1">{
        if head == nil </span><span class="cov0" title="0">{
                return head
        }</span>
        <span class="cov8" title="1">sentinel := &amp;node{
                Next: head,
        }
        current, prev := sentinel.Next, sentinel

        for current != nil </span><span class="cov8" title="1">{
                // 是否应该执行 k 区间反转
                tail := prev
                for i := 0; i &lt; k; i++ </span><span class="cov8" title="1">{
                        tail = tail.Next
                        if tail == nil </span><span class="cov8" title="1">{
                                // 当不能执行 k 个节点内的区间反转时，表示剩下接待不足 k 个，那么返回头节点
                                return sentinel.Next
                        }</span>
                }

                // 反转 k 个节点
                <span class="cov8" title="1">for i := 0; i &lt; k-1; i++ </span><span class="cov8" title="1">{
                        next := current.Next
                        current.Next = next.Next
                        next.Next = prev.Next
                        prev.Next = next
                }</span>
                // 此时 current 为 k 个节点区间内的 tail 尾节点
                <span class="cov8" title="1">prev = current
                // 进入下一个 k 区间
                current = current.Next</span>
        }

        <span class="cov8" title="1">return sentinel.Next</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package hard76

import "math"

// MinWindow is used to find minimum window substring
func MinWindow(s, t string) string <span class="cov8" title="1">{
        left, right := 0, 0 // 左闭右开
        // needsMap 为目标字符串的字母频率映射
        // windowMap 为窗口字符串的字母频率映射
        needsMap, windowMap := map[byte]int{}, map[byte]int{}
        // 表示满足 needsMap 的条件的字符个数，如果 validsInWindow 与 needsMap 的大小相同
        // 那么说明窗口已经满足条件，即已经完全覆盖 T
        validsInWindow := 0
        answerStart, answerLength := 0, math.MaxInt32

        for i := range t </span><span class="cov8" title="1">{
                needsMap[t[i]]++
        }</span>

        <span class="cov8" title="1">for right &lt; len(s) </span><span class="cov8" title="1">{
                // 即将进入窗口的字符
                current := s[right]
                right++ // 增大窗口
                // 如果是目标单字符，那么更新映射中的单个字符频率
                if _, ok := needsMap[current]; ok </span><span class="cov8" title="1">{
                        windowMap[current]++
                        // 仅在相同频率时，才会更新 validsInWindow
                        if windowMap[current] == needsMap[current] </span><span class="cov8" title="1">{
                                validsInWindow++
                        }</span>
                }

                // 即已经存在可覆盖 T 的窗口，此时窗口中对应到 t 中单个字符的频率一定等于 t 中
                // 对应的单个字符的频率
                <span class="cov8" title="1">for validsInWindow == len(needsMap) </span><span class="cov8" title="1">{
                        // 当当前窗口长度小于原有值时，更新最小长度
                        if right-left &lt; answerLength </span><span class="cov8" title="1">{
                                answerStart = left
                                answerLength = right - left
                        }</span>
                        // 缩小窗口，为了尽可能找到满足覆盖 t 的最短子串
                        <span class="cov8" title="1">deleted := s[left]
                        left++
                        // 因为缩小了窗口，故要移除对应的字符频率
                        if _, ok := needsMap[deleted]; ok </span><span class="cov8" title="1">{
                                // ！易错点
                                if windowMap[deleted] == needsMap[deleted] </span><span class="cov8" title="1">{
                                        validsInWindow--
                                }</span>
                                // ！易错点
                                <span class="cov8" title="1">windowMap[deleted]--</span>
                        }
                }
        }

        <span class="cov8" title="1">if answerLength == math.MaxInt32 </span><span class="cov0" title="0">{
                return ``
        }</span>
        <span class="cov8" title="1">return s[answerStart:(answerStart + answerLength)]</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package medium103

import (
        structures "leetcode-solutions/data-structures"
)

type node = structures.BinaryTreeNode

func zigzagLevelOrder(root *node) (ans [][]int) <span class="cov8" title="1">{
        if root == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">queue := []*node{root}
        for len(queue) &gt; 0 </span><span class="cov8" title="1">{
                levelSize := len(queue)
                level := make([]int, levelSize)
                levelIndex := len(ans)
                for i := 0; i &lt; levelSize; i++ </span><span class="cov8" title="1">{
                        current := queue[0]
                        queue = queue[1:]

                        if levelIndex%2 &gt; 0 </span><span class="cov8" title="1">{
                                level[levelSize-1-i] = current.Val
                        }</span> else<span class="cov8" title="1"> {
                                level[i] = current.Val
                        }</span>

                        <span class="cov8" title="1">if current.Left != nil </span><span class="cov8" title="1">{
                                queue = append(queue, current.Left)
                        }</span>
                        <span class="cov8" title="1">if current.Right != nil </span><span class="cov8" title="1">{
                                queue = append(queue, current.Right)
                        }</span>
                }
                <span class="cov8" title="1">ans = append(ans, level)</span>
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package medium1038

import (
        structures "leetcode-solutions/data-structures"
)

type node = structures.BinaryTreeNode

func bstToGst(root *node) *node <span class="cov8" title="1">{
        var prev int
        var dfs func(root *node) *node
        dfs = func(root *node) *node </span><span class="cov0" title="0">{
                if root == nil </span><span class="cov0" title="0">{
                        return root
                }</span>
                <span class="cov0" title="0">dfs(root.Right)
                prev += root.Val
                root.Val = prev
                dfs(root.Left)
                return root</span>
        }
        <span class="cov8" title="1">return root</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package medium105

import (
        structures "leetcode-solutions/data-structures"
)

type node = structures.BinaryTreeNode

func buildTree(preorder, inorder []int) *node <span class="cov8" title="1">{
        if len(preorder) &lt; 1 || len(inorder) &lt; 1 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">val := preorder[0]
        var i int
        for i = range inorder </span><span class="cov8" title="1">{
                if inorder[i] == val </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return &amp;node{
                Val: val,
                // 保证传入的 preorder 和 inorder 长度相等，才能保证每次都能找到 root 值
                // 故 preorder 结束项为 i+1
                Left:  buildTree(preorder[1:i+1], inorder[:i]),
                Right: buildTree(preorder[i+1:], inorder[i+1:]),
        }</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package medium106

import (
        structures "leetcode-solutions/data-structures"
)

type node = structures.BinaryTreeNode

func buildTree(inorder, postorder []int) *node <span class="cov8" title="1">{
        if len(inorder) == 0 || len(postorder) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">rootVal := postorder[len(postorder)-1]
        // based on unique value
        var i int
        for i = range inorder </span><span class="cov8" title="1">{
                if inorder[i] == rootVal </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        // 找到区分左右子树的值，那么此时该值左右两边分别对应左右子树
        <span class="cov8" title="1">return &amp;node{
                Val: rootVal,
                // 划分左边结果数组，构建左子树
                Left: buildTree(inorder[:i], postorder[:i]),
                // 反之，构建右子树
                Right: buildTree(inorder[i+1:], postorder[i:(len(postorder)-1)]),
        }</span>
        // 每次递归后，inorder 中都会移除第 i 项(即 root 值)，postorder 中都会移除末项（即 root 值）
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package medium109

import (
        structures "leetcode-solutions/data-structures"
)

type list = structures.LinkedListNode
type node = structures.BinaryTreeNode

// time complexity: O(nlogn), space complexity: O(logn)，即结果平衡二叉树高度
func sortedListToBST(head *list) *node <span class="cov8" title="1">{
        if head == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        // find middle node in the list
        <span class="cov8" title="1">slow, fast := head, head
        var prev *list
        for fast != nil &amp;&amp; fast.Next != nil </span><span class="cov8" title="1">{
                prev = slow
                slow = slow.Next
                fast = fast.Next.Next
        }</span>

        <span class="cov8" title="1">root := &amp;node{
                Val: slow.Val,
        }

        // recursion base case
        if head == slow </span><span class="cov8" title="1">{
                return root
        }</span>

        <span class="cov8" title="1">if prev != nil </span><span class="cov8" title="1">{
                prev.Next = nil
        }</span>

        <span class="cov8" title="1">root.Left = sortedListToBST(head)
        root.Right = sortedListToBST(slow.Next)
        return root</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package medium11

func maxArea(height []int) int <span class="cov8" title="1">{
        left, right, answer := 0, len(height)-1, 0
        for right &gt; left </span><span class="cov8" title="1">{
                area := (right - left) * min(height[left], height[right])
                answer = max(area, answer)
                if height[left] &gt;= height[right] </span><span class="cov8" title="1">{
                        right--
                }</span> else<span class="cov8" title="1"> {
                        left++
                }</span>
        }
        <span class="cov8" title="1">return answer</span>
}

func min(a, b int) int <span class="cov8" title="1">{
        if a &gt; b </span><span class="cov8" title="1">{
                return b
        }</span>
        <span class="cov8" title="1">return a</span>
}

func max(a, b int) int <span class="cov8" title="1">{
        if a &gt; b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package medium113

import (
        structures "leetcode-solutions/data-structures"
)

type node = structures.BinaryTreeNode

func pathSum(root *node, sum int) (answer [][]int) <span class="cov8" title="1">{
        path := []int{}
        var dfs func(*node, int)
        dfs = func(root *node, sum int) </span><span class="cov8" title="1">{
                if root == nil </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">sum -= root.Val
                path = append(path, root.Val)
                if root.Left == nil &amp;&amp; root.Right == nil &amp;&amp; sum == 0 </span><span class="cov8" title="1">{
                        answer = append(answer, append([]int(nil), path...))
                }</span>
                // 深入 root 的左子树，进而通过下一层检查来检查是否存在符合要求的路径
                <span class="cov8" title="1">dfs(root.Left, sum)
                // 深入 root 的右子树，进而通过下一层检查来检查是否存在符合要求的路径
                dfs(root.Right, sum)
                /*
                        移除 root 本身，因为包含 root 的路径已经在上述代码中遍历完成，故 **针对递归栈中** 之后的遍历得到路径中无 root 节点
                */
                path = path[:len(path)-1]</span>
        }
        // 前序遍历
        <span class="cov8" title="1">dfs(root, sum)
        return</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package medium114

import (
        structures "leetcode-solutions/data-structures"
)

type node = structures.BinaryTreeNode

func flatten0(root *node) <span class="cov8" title="1">{
        if root == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">stack := []*node{root}
        var prev *node
        for len(stack) &gt; 0 </span><span class="cov8" title="1">{
                index := len(stack) - 1
                current := stack[index]
                stack = stack[:index]

                // 相较于普通迭代法前序遍历多的步骤
                if prev != nil </span><span class="cov8" title="1">{
                        prev.Left, prev.Right = nil, current
                }</span>
                <span class="cov8" title="1">prev = current

                if current.Right != nil </span><span class="cov8" title="1">{
                        stack = append(stack, current.Right)
                }</span>
                <span class="cov8" title="1">if current.Left != nil </span><span class="cov8" title="1">{
                        stack = append(stack, current.Left)
                }</span>
        }
}

func flatten1(root *node) <span class="cov8" title="1">{
        if root == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">order := []*node{}
        stack := []*node{root}
        for len(stack) &gt; 0 </span><span class="cov8" title="1">{
                index := len(stack) - 1
                current := stack[index]
                stack = stack[:index]
                order = append(order, current)
                if current.Right != nil </span><span class="cov8" title="1">{
                        stack = append(stack, current.Right)
                }</span>
                <span class="cov8" title="1">if current.Left != nil </span><span class="cov8" title="1">{
                        stack = append(stack, current.Left)
                }</span>
        }

        <span class="cov8" title="1">for i := 1; i &lt; len(order); i++ </span><span class="cov8" title="1">{
                prev := order[i-1]
                prev.Left = nil
                prev.Right = order[i]
        }</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package medium129

import (
        structures "leetcode-solutions/data-structures"
        "strconv"
)

type node = structures.BinaryTreeNode

/*
        思路同 medium 113 路径总和 ii
        时间复杂度：O(N2)
        空间复杂度：O(N)
*/
func sumNumbers(root *node) int <span class="cov8" title="1">{
        paths := []string{}
        current := ""
        var dfs func(*node)
        dfs = func(root *node) </span><span class="cov8" title="1">{
                if root == nil </span><span class="cov8" title="1">{
                        return
                }</span>

                <span class="cov8" title="1">current += strconv.Itoa(root.Val)

                if root.Left == nil &amp;&amp; root.Right == nil </span><span class="cov8" title="1">{
                        paths = append(paths, current)
                }</span>
                <span class="cov8" title="1">dfs(root.Left)
                dfs(root.Right)
                current = current[:len(current)-1]</span>
        }
        <span class="cov8" title="1">dfs(root)
        var ans int
        for _, path := range paths </span><span class="cov8" title="1">{
                if num, err := strconv.Atoi(path); err == nil </span><span class="cov8" title="1">{
                        ans += num
                }</span>
        }
        <span class="cov8" title="1">return ans</span>
}

/*
        时间复杂度：O(N)
        空间复杂度：O(N)
*/
func sumNumbers0(root *node) int <span class="cov8" title="1">{
        var dfs func(*node, int) int
        dfs = func(root *node, prev int) int </span><span class="cov8" title="1">{
                if root == nil </span><span class="cov0" title="0">{
                        return 0
                }</span>
                <span class="cov8" title="1">sum := prev*10 + root.Val
                if root.Left == nil &amp;&amp; root.Right == nil </span><span class="cov8" title="1">{
                        return sum
                }</span>
                <span class="cov8" title="1">return dfs(root.Left, sum) + dfs(root.Right, sum)</span>
        }
        <span class="cov8" title="1">return dfs(root, 0)</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package medium137

func singleNumber(nums []int) int <span class="cov8" title="1">{
        seenOnce, seenTwice := 0, 0

        for _, num := range nums </span><span class="cov8" title="1">{
                // golang 中使用前缀 ^ 表示按位非，而不是前缀 ~
                seenOnce = ^seenTwice &amp; (seenOnce ^ num)
                seenTwice = ^seenOnce &amp; (seenTwice ^ num)
        }</span>

        <span class="cov8" title="1">return seenOnce</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">package medium142

import (
        structures "leetcode-solutions/data-structures"
)

type node = structures.LinkedListNode

func detectCycle(head *node) *node <span class="cov8" title="1">{
        slow, fast := head, head
        for fast != nil &amp;&amp; fast.Next != nil </span><span class="cov8" title="1">{
                slow = slow.Next
                fast = fast.Next.Next
                if fast == slow </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        // 无环
        <span class="cov8" title="1">if fast == nil || fast.Next == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        // 有环
        <span class="cov8" title="1">slow = head
        for fast != slow </span><span class="cov8" title="1">{
                fast = fast.Next
                slow = slow.Next
        }</span>
        <span class="cov8" title="1">return slow</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package medium143

import structures "leetcode-solutions/data-structures"

type node = structures.LinkedListNode

func reorderList(head *node) <span class="cov8" title="1">{
        if head == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">nodes := []*node{}
        current := head
        for current != nil </span><span class="cov8" title="1">{
                nodes = append(nodes, current)
                current = current.Next
        }</span>

        <span class="cov8" title="1">i, j := 0, len(nodes)-1
        for i &lt; j </span><span class="cov8" title="1">{
                nodes[i].Next = nodes[j]
                i++
                if i == j </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">nodes[j].Next = nodes[i]
                j--</span>
        }
        <span class="cov8" title="1">nodes[i].Next = nil</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">package medium144

import (
        structures "leetcode-solutions/data-structures"
)

func preorderTraversal(root *structures.BinaryTreeNode) []int <span class="cov8" title="1">{
        answer := []int{}
        if root == nil </span><span class="cov0" title="0">{
                return answer
        }</span>

        <span class="cov8" title="1">stack := []*structures.BinaryTreeNode{root}
        for len(stack) &gt; 0 </span><span class="cov8" title="1">{
                currentIndex := len(stack) - 1
                current := stack[currentIndex]
                stack, answer = stack[:currentIndex], append(answer, current.Val)

                if current.Right != nil </span><span class="cov8" title="1">{
                        stack = append(stack, current.Right)
                }</span>
                <span class="cov8" title="1">if current.Left != nil </span><span class="cov8" title="1">{
                        stack = append(stack, current.Left)
                }</span>
        }

        <span class="cov8" title="1">return answer</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">package medium147

import (
        structures "leetcode-solutions/data-structures"
)

type node = structures.LinkedListNode

func insertionSortlist(head *node) *node <span class="cov8" title="1">{
        if head == nil </span><span class="cov0" title="0">{
                return head
        }</span>
        <span class="cov8" title="1">sentinel := &amp;node{Next: head}
        sortedPartTail, current := head, head.Next
        for current != nil </span><span class="cov8" title="1">{
                if sortedPartTail.Val &lt;= current.Val </span><span class="cov8" title="1">{
                        sortedPartTail = sortedPartTail.Next
                }</span> else<span class="cov8" title="1"> {
                        prev := sentinel
                        for prev.Next.Val &lt;= current.Val </span><span class="cov8" title="1">{
                                prev = prev.Next
                        }</span>
                        <span class="cov8" title="1">sortedPartTail.Next = current.Next // remove current from list

                        // resume link
                        current.Next = prev.Next
                        prev.Next = current</span>
                }
                <span class="cov8" title="1">current = sortedPartTail.Next</span>
        }
        <span class="cov8" title="1">return sentinel.Next</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">package medium15

import "sort"

// ThreeSum is used to
func ThreeSum(nums []int) [][]int <span class="cov8" title="1">{
        answer := [][]int{}

        // 将 slice 排序
        sort.Ints(nums)

        // 将三数之和问题转换为固定一项的两数之和问题
        for i := 0; i &lt; len(nums); i++ </span><span class="cov8" title="1">{
                tuples := twoSumTarget(nums, i+1, 0-nums[i])
                for _, tuple := range tuples </span><span class="cov8" title="1">{
                        answer = append(answer, append(tuple, nums[i]))
                }</span>
                // 通过以下迭代来防止三项中的首项出现重复
                <span class="cov8" title="1">for i &lt; len(nums)-1 &amp;&amp; (nums[i] == nums[i+1]) </span><span class="cov8" title="1">{
                        i++
                }</span>
        }

        <span class="cov8" title="1">return answer</span>
}

func twoSumTarget(nums []int, start int, target int) [][]int <span class="cov8" title="1">{
        low, high, answer := start, len(nums)-1, [][]int{}

        for low &lt; high </span><span class="cov8" title="1">{
                left, right := nums[low], nums[high]
                sum := left + right
                if sum &gt; target </span><span class="cov8" title="1">{
                        for low &lt; high &amp;&amp; (nums[high] == right) </span><span class="cov8" title="1">{
                                high--
                        }</span>
                } else<span class="cov8" title="1"> if sum &lt; target </span><span class="cov8" title="1">{
                        for low &lt; high &amp;&amp; (nums[low] == left) </span><span class="cov8" title="1">{
                                low++
                        }</span>
                } else<span class="cov8" title="1"> {
                        answer = append(answer, []int{left, right})
                        // 通过迭代跳过重复项
                        for low &lt; high &amp;&amp; (nums[low] == left) </span><span class="cov8" title="1">{
                                low++
                        }</span>
                        <span class="cov8" title="1">for low &lt; high &amp;&amp; (nums[high] == right) </span><span class="cov8" title="1">{
                                high--
                        }</span>
                }
        }

        <span class="cov8" title="1">return answer</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package medium153

/* 另一种二分查找实现见 hard-154（推荐查看 hard-154 解法更为简洁，且支持存在重复值的查找） */

func findMin(nums []int) int <span class="cov8" title="1">{
        if len(nums) == 1 </span><span class="cov0" title="0">{
                return nums[0]
        }</span>

        <span class="cov8" title="1">left, right := 0, len(nums)-1
        /*
                原本数组是升序排列，那么旋转后的首项在原位置大于旋转后的末项。如：
                前 ： 1 2 3 4 5 6 7
                后 ： 4 5 6 7 1 2 3
                由上可见，before[2] &lt; before[3], after[7] &lt; after[0]
        */
        /*
                当旋转后的数组 nums[0] &lt; nums[right] 时，表示此时数组已经排序，故 nums[0] 为最小值
        */
        if nums[0] &lt; nums[right] </span><span class="cov8" title="1">{
                return nums[0]
        }</span>

        <span class="cov8" title="1">for left &lt;= right </span><span class="cov8" title="1">{
                pivot := left + (right-left)/2

                /*
                        根据原数组是升序的特点，升序排列应该是前项始终不大于后项，那么当前项大于后项时，那么后项即为旋转点，那么此时的后项为原升序数组中的最小值
                */
                // 注意必须搜先判断 pivot 与 后项是否相等，之后再判断与 pivot-1 项，因为 pivot 可为 0
                if nums[pivot] &gt; nums[pivot+1] </span><span class="cov8" title="1">{
                        return nums[pivot+1]
                }</span>
                // 同上 if 语句
                <span class="cov0" title="0">if nums[pivot-1] &gt; nums[pivot] </span><span class="cov0" title="0">{
                        return nums[pivot]
                }</span>
                /*
                        基于原数组的升序排列，且基于前两个 pivot 判断，pivot 不为断开项时，
                        那么当 pivot 项大于首项时，那么至少在 0 ~ pivot 项之间是不存在断点项的，那么右移 left 至 pivot + 1 项
                */
                <span class="cov0" title="0">if nums[pivot] &gt; nums[0] </span><span class="cov0" title="0">{
                        left = pivot + 1
                }</span> else<span class="cov0" title="0"> {
                        right = pivot - 1
                }</span>
        }

        <span class="cov0" title="0">return -1</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">package medium16

import (
        "math"
        "sort"
)

func threeSumClosest(nums []int, target int) int <span class="cov8" title="1">{
        sort.Ints(nums)
        answer := math.MaxInt32

        for i := 0; i &lt; len(nums); i++ </span><span class="cov8" title="1">{
                low, high := i+1, len(nums)-1

                for low &lt; high </span><span class="cov8" title="1">{
                        left, right := nums[low], nums[high]
                        sum := left + right + nums[i]

                        /*
                                此处若 sum 为两数之和，那么 sum 需与 target - nums[i] 计算差值，而 answer 应与之前的 nums[i] 计算差值
                        */
                        if abs(sum-target) &lt; abs(answer-target) </span><span class="cov8" title="1">{
                                answer = sum
                        }</span>

                        <span class="cov8" title="1">if sum &gt; target </span><span class="cov8" title="1">{
                                for low &lt; high &amp;&amp; (nums[high] == right) </span><span class="cov8" title="1">{
                                        high--
                                }</span>
                        } else<span class="cov8" title="1"> if sum &lt; target </span><span class="cov8" title="1">{
                                for low &lt; high &amp;&amp; (nums[low] == left) </span><span class="cov8" title="1">{
                                        low++
                                }</span>
                        } else<span class="cov0" title="0"> {
                                return sum
                        }</span>
                }

                <span class="cov8" title="1">for i &lt; len(nums)-1 &amp;&amp; (nums[i] == nums[i+1]) </span><span class="cov0" title="0">{
                        i++
                }</span>
        }

        <span class="cov8" title="1">return answer</span>
}

func abs(a int) int <span class="cov8" title="1">{
        if a &lt; 0 </span><span class="cov8" title="1">{
                return -1 * a
        }</span>
        <span class="cov8" title="1">return a</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">package medium1609

import (
        structures "leetcode-solutions/data-structures"
        "math"
)

type node = structures.BinaryTreeNode

func isEvenOddTree(root *node) bool <span class="cov8" title="1">{
        if root == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">queue := []*node{root}
        levelIndex := -1
        for len(queue) &gt; 0 </span><span class="cov8" title="1">{
                levelIndex++
                levelSize := len(queue)
                var prev int
                if isOdd(levelIndex) </span><span class="cov8" title="1">{
                        prev = math.MaxInt64
                }</span> else<span class="cov8" title="1"> {
                        prev = math.MinInt64
                }</span>
                <span class="cov8" title="1">for i := 0; i &lt; levelSize; i++ </span><span class="cov8" title="1">{
                        current := queue[0]
                        queue = queue[1:]

                        if isOdd(levelIndex) </span><span class="cov8" title="1">{
                                if isOdd(current.Val) || (current.Val &gt;= prev) </span><span class="cov8" title="1">{
                                        return false
                                }</span>
                        } else<span class="cov8" title="1"> {
                                if !isOdd(current.Val) || (current.Val &lt;= prev) </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                        }

                        <span class="cov8" title="1">prev = current.Val

                        if current.Left != nil </span><span class="cov8" title="1">{
                                queue = append(queue, current.Left)
                        }</span>
                        <span class="cov8" title="1">if current.Right != nil </span><span class="cov8" title="1">{
                                queue = append(queue, current.Right)
                        }</span>
                }
        }
        <span class="cov8" title="1">return true</span>
}

func isOdd(val int) bool <span class="cov8" title="1">{
        return val%2 &gt; 0
}</span>
</pre>
		
		<pre class="file" id="file81" style="display: none">package medium1637

import "sort"

func maxWidthOfVerticalArea(points [][]int) int <span class="cov8" title="1">{
        sort.Slice(points, func(a, b int) bool </span><span class="cov8" title="1">{
                return points[a][0] &lt; points[b][0]
        }</span>)
        <span class="cov8" title="1">var max func(int, int) int
        max = func(a, b int) int </span><span class="cov8" title="1">{
                if a &gt; b </span><span class="cov8" title="1">{
                        return a
                }</span>
                <span class="cov8" title="1">return b</span>
        }
        <span class="cov8" title="1">var ans int
        for i := 0; i &lt; len(points)-1; i++ </span><span class="cov8" title="1">{
                current, after := points[i], points[i+1]
                ans = max(ans, after[0]-current[0])
        }</span>
        <span class="cov8" title="1">return ans</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">package medium1669

import structures "leetcode-solutions/data-structures"

type node = structures.LinkedListNode

func mergeInBetween(list1 *node, a, b int, list2 *node) *node <span class="cov8" title="1">{
        if list1 == nil </span><span class="cov8" title="1">{
                return list1
        }</span>

        <span class="cov8" title="1">sentinel := &amp;node{Next: list1}
        start, end := list1, list1
        for b &gt; -1 </span><span class="cov8" title="1">{
                if a &gt; 1 </span><span class="cov8" title="1">{
                        start = start.Next
                        a--
                }</span>
                <span class="cov8" title="1">end = end.Next
                b--</span>
        }

        <span class="cov8" title="1">start.Next = list2
        if list2 != nil </span><span class="cov8" title="1">{
                current := list2
                for current.Next != nil </span><span class="cov8" title="1">{
                        current = current.Next
                }</span>
                <span class="cov8" title="1">current.Next = end</span>
        }

        <span class="cov8" title="1">return sentinel.Next</span>
}
</pre>
		
		<pre class="file" id="file83" style="display: none">package medium17

import "strings"

func letterCombinations(digits string) []string <span class="cov8" title="1">{
        ans := []string{}

        if len(digits) &lt; 1 </span><span class="cov8" title="1">{
                return ans
        }</span>

        <span class="cov8" title="1">pendings := map[byte]string{
                '2': "abc",
                '3': "def",
                '4': "ghi",
                '5': "jkl",
                '6': "mno",
                '7': "pqrs",
                '8': "tuv",
                '9': "wxyz",
        }
        track := []string{}
        var backtracking func(int)
        backtracking = func(current int) </span><span class="cov8" title="1">{
                if len(track) == len(digits) </span><span class="cov8" title="1">{
                        ans = append(ans, strings.Join(track, ""))
                        return
                }</span>
                <span class="cov8" title="1">for _, char := range pendings[digits[current]] </span><span class="cov8" title="1">{
                        track = append(track, string(char))
                        backtracking(current + 1)
                        track = track[:len(track)-1]
                }</span>
        }

        <span class="cov8" title="1">backtracking(0)
        return ans</span>
}
</pre>
		
		<pre class="file" id="file84" style="display: none">package medium1721

import structures "leetcode-solutions/data-structures"

type node = structures.LinkedListNode

// 交换两节点
func swapNodes(head *node, k int) *node <span class="cov8" title="1">{
        if head == nil </span><span class="cov8" title="1">{
                return head
        }</span>

        <span class="cov8" title="1">sentinel := &amp;node{Next: head}
        current := sentinel

        for k &gt; 1 </span><span class="cov8" title="1">{
                current = current.Next
                k--
        }</span>

        <span class="cov8" title="1">left, right := current, sentinel

        for current.Next.Next != nil </span><span class="cov8" title="1">{
                current = current.Next
                right = right.Next
        }</span>

        // 待交换的两节点
        <span class="cov8" title="1">leftNext := right.Next
        rightNext := left.Next

        // 交换两节点
        left.Next = leftNext
        right.Next = rightNext

        // 交换的两节点的后续节点
        leftNextNext := rightNext.Next
        rightNextNext := leftNext.Next

        // 恢复交换的两节点的后续节点
        leftNext.Next = leftNextNext
        rightNext.Next = rightNextNext

        return sentinel.Next</span>
}

// 仅交换两节点的值
func swapNodesVal(head *node, k int) *node <span class="cov8" title="1">{
        if head == nil </span><span class="cov8" title="1">{
                return head
        }</span>

        <span class="cov8" title="1">current := head

        for k &gt; 1 </span><span class="cov8" title="1">{
                current = current.Next
                k--
        }</span>

        <span class="cov8" title="1">fast, slow := head, current

        for current.Next != nil </span><span class="cov8" title="1">{
                current = current.Next
                fast = fast.Next
        }</span>

        <span class="cov8" title="1">fast.Val, slow.Val = slow.Val, fast.Val

        return head</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">package medium18

import "sort"

// FourSum function is used to solve four sum problems.
func FourSum(nums []int, target int) [][]int <span class="cov8" title="1">{
        answer := [][]int{}
        sort.Ints(nums)

        for i := 0; i &lt; len(nums); i++ </span><span class="cov8" title="1">{
                triples := threeSumTarget(nums, i+1, target-nums[i])
                for _, triple := range triples </span><span class="cov8" title="1">{
                        answer = append(answer, append(triple, nums[i]))
                }</span>
                <span class="cov8" title="1">for i &lt; len(nums)-1 &amp;&amp; nums[i] == nums[i+1] </span><span class="cov8" title="1">{
                        i++
                }</span>
        }

        <span class="cov8" title="1">return answer</span>
}

/*
        见 medium15 中对下文方程的解析
*/
func threeSumTarget(nums []int, start int, target int) [][]int <span class="cov8" title="1">{
        answer := [][]int{}

        for i := start; i &lt; len(nums)-1; i++ </span><span class="cov8" title="1">{
                tuples := twoSumTarget(nums, i+1, target-nums[i])
                for _, tuple := range tuples </span><span class="cov8" title="1">{
                        answer = append(answer, append(tuple, nums[i]))
                }</span>
                <span class="cov8" title="1">for i &lt; len(nums)-1 &amp;&amp; nums[i] == nums[i+1] </span><span class="cov8" title="1">{
                        i++
                }</span>
        }

        <span class="cov8" title="1">return answer</span>
}

/*
        见 medium15 中对下文方程的解析
*/
func twoSumTarget(nums []int, start int, target int) [][]int <span class="cov8" title="1">{
        low, high, answer := start, len(nums)-1, [][]int{}

        for low &lt; high </span><span class="cov8" title="1">{
                left, right := nums[low], nums[high]
                sum := left + right
                if sum &gt; target </span><span class="cov8" title="1">{
                        for low &lt; high &amp;&amp; nums[high] == right </span><span class="cov8" title="1">{
                                high--
                        }</span>
                } else<span class="cov8" title="1"> if sum &lt; target </span><span class="cov8" title="1">{
                        for low &lt; high &amp;&amp; (nums[low] == left) </span><span class="cov8" title="1">{
                                low++
                        }</span>
                } else<span class="cov8" title="1"> {
                        answer = append(answer, []int{left, right})
                        for low &lt; high &amp;&amp; (nums[high] == right) </span><span class="cov8" title="1">{
                                high--
                        }</span>
                        <span class="cov8" title="1">for low &lt; high &amp;&amp; (nums[low] == left) </span><span class="cov8" title="1">{
                                low++
                        }</span>
                }
        }

        <span class="cov8" title="1">return answer</span>
}
</pre>
		
		<pre class="file" id="file86" style="display: none">package medium189

func rotate(nums []int, k int) <span class="cov8" title="1">{
        extra := make([]int, len(nums))
        for i, v := range nums </span><span class="cov8" title="1">{
                extra[(i+k)%len(nums)] = v
        }</span>
        <span class="cov8" title="1">copy(nums, extra)</span>
}

/*
        nums = "-----&gt;--&gt;"; k =3
        result = "--&gt;-----&gt;";

        reverse "-----&gt;--&gt;" we can get "&lt;--&lt;-----"
        reverse "&lt;--" we can get "--&gt;&lt;-----"
        reverse "&lt;-----" we can get "--&gt;-----&gt;"
*/
func rotate0(nums []int, k int) <span class="cov8" title="1">{
        var reverse func([]int)
        reverse = func(nums []int) </span><span class="cov8" title="1">{
                n := len(nums)
                for i := 0; i &lt; n/2; i++ </span><span class="cov8" title="1">{
                        nums[i], nums[n-1-i] = nums[n-1-i], nums[i]
                }</span>
        }

        <span class="cov8" title="1">k = k % len(nums)
        reverse(nums)
        reverse(nums[:k])
        reverse(nums[k:])</span>
}
</pre>
		
		<pre class="file" id="file87" style="display: none">package medium19

import (
        structures "leetcode-solutions/data-structures"
)

func removeNthFromEnd(head *structures.LinkedListNode, n int) *structures.LinkedListNode <span class="cov8" title="1">{
        sentinel := &amp;structures.LinkedListNode{
                Next: head,
        }
        slow, fast := sentinel, sentinel

        for i := 1; i &lt;= n+1; i++ </span><span class="cov8" title="1">{
                fast = fast.Next
        }</span>

        <span class="cov8" title="1">for fast != nil </span><span class="cov8" title="1">{
                fast = fast.Next
                slow = slow.Next
        }</span>

        <span class="cov8" title="1">slow.Next = slow.Next.Next
        return sentinel.Next</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">package medium2

import (
        structures "leetcode-solutions/data-structures"
)

type node = structures.LinkedListNode

func addTwoNumbers(l1 *node, l2 *node) *node <span class="cov8" title="1">{
        sentinel := &amp;node{}
        current, current1, current2, carry := sentinel, l1, l2, 0
        for current1 != nil || current2 != nil </span><span class="cov8" title="1">{
                var sum int
                if current1 != nil </span><span class="cov8" title="1">{
                        sum += current1.Val
                        current1 = current1.Next
                }</span>
                <span class="cov8" title="1">if current2 != nil </span><span class="cov8" title="1">{
                        sum += current2.Val
                        current2 = current2.Next
                }</span>
                <span class="cov8" title="1">sum += carry
                carry = sum / 10
                current.Next = &amp;node{Val: sum % 10}
                current = current.Next</span>
        }
        <span class="cov8" title="1">if carry != 0 </span><span class="cov0" title="0">{
                current.Next = &amp;node{Val: carry}
        }</span>
        <span class="cov8" title="1">return sentinel.Next</span>
}
</pre>
		
		<pre class="file" id="file89" style="display: none">package medium208

// TrieViaArray defines a trie tree node based on array/slice
type TrieViaArray struct {
        isWord bool
        next   [26]*TrieViaArray
}

// Create is used to create a trie tree node
func Create() TrieViaArray <span class="cov8" title="1">{
        return TrieViaArray{}
}</span>

// Insert is used to insert node if the path does not exist
func (root *TrieViaArray) Insert(word string) <span class="cov8" title="1">{
        for _, char := range word </span><span class="cov8" title="1">{
                index := char - 'a'
                if ptr := root.next[index]; ptr == nil </span><span class="cov8" title="1">{
                        root.next[index] = new(TrieViaArray)
                }</span>
                <span class="cov8" title="1">root = root.next[index]</span>
        }
        <span class="cov8" title="1">root.isWord = true</span>
}

// Search is used to search node from the current tree
func (root *TrieViaArray) Search(word string) bool <span class="cov8" title="1">{
        for _, char := range word </span><span class="cov8" title="1">{
                index := char - 'a'
                if ptr := root.next[index]; ptr == nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">root = root.next[index]</span>
        }
        <span class="cov8" title="1">return root.isWord</span>
}

// StartsWith is used to judge prefix string
func (root *TrieViaArray) StartsWith(prefix string) bool <span class="cov8" title="1">{
        for _, char := range prefix </span><span class="cov8" title="1">{
                index := char - 'a'
                if ptr := root.next[index]; ptr == nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">root = root.next[index]</span>
        }
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file90" style="display: none">package medium208

// Trie defines a trie tree node
type Trie struct {
        isWord bool
        child  map[rune]*Trie
}

// CreateTrie is u`sed to create a trie tree node
func CreateTrie() Trie <span class="cov8" title="1">{
        return Trie{isWord: false, child: make(map[rune]*Trie)}
}</span>

// Insert is used to insert node if the path does not exist
func (root *Trie) Insert(word string) <span class="cov8" title="1">{
        node := root
        for _, char := range word </span><span class="cov8" title="1">{
                if _, ok := node.child[char]; !ok </span><span class="cov8" title="1">{
                        child := CreateTrie()
                        node.child[char] = &amp;child
                }</span>
                <span class="cov8" title="1">node = node.child[char]</span>
        }
        // leaf node is word type node
        <span class="cov8" title="1">node.isWord = true</span>
}

// Search is used to search node from the current tree
func (root *Trie) Search(word string) bool <span class="cov8" title="1">{
        node := root
        for _, char := range word </span><span class="cov8" title="1">{
                if _, ok := node.child[char]; !ok </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">node = node.child[char]</span>
        }
        <span class="cov8" title="1">return node.isWord</span>
}

// StartsWith is used to judge prefix string
func (root *Trie) StartsWith(prefix string) bool <span class="cov8" title="1">{
        node := root
        for _, char := range prefix </span><span class="cov8" title="1">{
                if _, ok := node.child[char]; !ok </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">node = node.child[char]</span>
        }
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file91" style="display: none">package medium209

import "math"

func minSubArrayLen(s int, nums []int) int <span class="cov8" title="1">{
        slow, fast, answer, sum := 0, 0, math.MaxInt32, 0

        for fast &lt; len(nums) </span><span class="cov8" title="1">{
                sum += nums[fast]
                fast++

                for sum &gt;= s </span><span class="cov8" title="1">{
                        answer = min(fast-slow, answer)
                        deleted := nums[slow]
                        slow++
                        sum -= deleted
                }</span>
        }

        <span class="cov8" title="1">if answer == math.MaxInt32 </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">return answer</span>
}

func min(a, b int) int <span class="cov8" title="1">{
        if a &lt; b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">package medium215

func findKthLargest(nums []int, k int) int <span class="cov8" title="1">{
        sort(nums, 0, len(nums)-1)
        return nums[k-1]
}</span>

func sort(nums []int, low, high int) <span class="cov8" title="1">{
        if low &gt;= high </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">index := partition(nums, low, high)
        sort(nums, low, index-1)
        sort(nums, index+1, high)</span>
}

func partition(nums []int, low, high int) int <span class="cov8" title="1">{
        swap(nums, low+((high-low)&gt;&gt;1), high)
        pivot, slow := nums[high], low
        for fast := slow; fast &lt; high; fast++ </span><span class="cov8" title="1">{
                if nums[fast] &gt; pivot </span><span class="cov8" title="1">{
                        swap(nums, fast, slow)
                        slow++
                }</span>
        }
        <span class="cov8" title="1">swap(nums, slow, high)
        return slow</span>
}

func swap(nums []int, a, b int) <span class="cov8" title="1">{
        nums[a], nums[b] = nums[b], nums[a]
}</span>
</pre>
		
		<pre class="file" id="file93" style="display: none">package medium22

import "strings"

func generateParenthesis(n int) []string <span class="cov8" title="1">{
        ans := []string{}
        str := []string{}
        var dfs func(int, int)
        dfs = func(left, right int) </span><span class="cov8" title="1">{
                if len(str) == 2*n </span><span class="cov8" title="1">{
                        ans = append(ans, strings.Join(str, ""))
                        return
                }</span>

                <span class="cov8" title="1">if left &lt; n </span><span class="cov8" title="1">{
                        str = append(str, "(")
                        dfs(left+1, right)
                        str = str[:len(str)-1]
                }</span>
                <span class="cov8" title="1">if right &lt; left </span><span class="cov8" title="1">{
                        str = append(str, ")")
                        dfs(left, right+1)
                        str = str[:len(str)-1]
                }</span>
        }

        <span class="cov8" title="1">dfs(0, 0)
        return ans</span>
}

func generateParenthesis0(n int) (ans []string) <span class="cov8" title="1">{
        str := []string{}
        var dfs func(int, int)
        dfs = func(left, right int) </span><span class="cov8" title="1">{
                if left &gt; n || (right &gt; left) </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">if len(str) == 2*n </span><span class="cov8" title="1">{
                        ans = append(ans, strings.Join(str, ""))
                        return
                }</span>

                // for 循环选择列表为 []{"(", ")"}
                <span class="cov8" title="1">str = append(str, "(")
                dfs(left+1, right)
                str = str[:len(str)-1]

                str = append(str, ")")
                dfs(left, right+1)
                str = str[:len(str)-1]</span>
        }
        <span class="cov8" title="1">dfs(0, 0)
        return</span>
}
</pre>
		
		<pre class="file" id="file94" style="display: none">package medium230

import structures "leetcode-solutions/data-structures"

type node = structures.BinaryTreeNode

// 基于二叉搜索树的中序遍历为 小到大 升序的特点
func kthSmallest(root *node, k int) int <span class="cov8" title="1">{
        stack := []*node{}
        current := root
        for current != nil || len(stack) &gt; 0 </span><span class="cov8" title="1">{
                for current != nil </span><span class="cov8" title="1">{
                        stack = append(stack, current)
                        current = current.Left
                }</span>
                <span class="cov8" title="1">topFrame := len(stack) - 1
                current = stack[topFrame]
                stack = stack[:topFrame]
                k--
                if k == 0 </span><span class="cov8" title="1">{
                        return current.Val
                }</span>
                <span class="cov0" title="0">current = current.Right</span>
        }

        <span class="cov0" title="0">return *(*int)(nil)</span>
}
</pre>
		
		<pre class="file" id="file95" style="display: none">package medium236

import (
        structures "leetcode-solutions/data-structures"
)

type node = structures.BinaryTreeNode

func lowestCommonAncestor(root, p, q *node) *node <span class="cov8" title="1">{
        if root == nil || root == p || root == q </span><span class="cov8" title="1">{
                return root
        }</span>

        // 递归遍历 left 和 right 子树中，是否包含 p **或** q 节点
        <span class="cov8" title="1">left := lowestCommonAncestor(root.Left, p, q)
        right := lowestCommonAncestor(root.Right, p, q)

        // 如果左右子树均不包含 p 或 q，那么 p 和 q 并不存在于树种
        if left == nil &amp;&amp; right == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // 若左右子树均返回节点，那么最近公共祖先节点即为当前 root 节点
        // 以上基于后序遍历，那么始终从最底层的叶子节点开始更新，那么在所有满足条件的祖先
        // 节点种一定是最近的组件节点首先被访问到
        <span class="cov8" title="1">if left != nil &amp;&amp; right != nil </span><span class="cov8" title="1">{
                return root
        }</span>

        <span class="cov0" title="0">if left == nil </span><span class="cov0" title="0">{
                return right
        }</span>
        <span class="cov0" title="0">return left</span>
}
</pre>
		
		<pre class="file" id="file96" style="display: none">package medium238

func productExceptSelfOn(nums []int) []int <span class="cov8" title="1">{
        n := len(nums)
        l, r, ans := make([]int, n), make([]int, n), make([]int, n)
        l[0], r[n-1] = 1, 1

        for i := 1; i &lt; n; i++ </span><span class="cov8" title="1">{
                l[i] = nums[i-1] * l[i-1]
        }</span>

        <span class="cov8" title="1">for i := n - 2; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                r[i] = nums[i+1] * r[i+1]
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                ans[i] = l[i] * r[i]
        }</span>

        <span class="cov8" title="1">return ans</span>
}

func productExceptSelfO1(nums []int) []int <span class="cov8" title="1">{
        n := len(nums)
        ans := make([]int, n)
        ans[0] = 1

        for i := 1; i &lt; n; i++ </span><span class="cov8" title="1">{
                ans[i] = nums[i-1] * ans[i-1]
        }</span>

        <span class="cov8" title="1">r := 1
        for i := n - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                ans[i] = ans[i] * r
                r *= nums[i]
        }</span>

        <span class="cov8" title="1">return ans</span>
}
</pre>
		
		<pre class="file" id="file97" style="display: none">package medium24

import (
        structures "leetcode-solutions/data-structures"
)

func swapPairs(head *structures.LinkedListNode) *structures.LinkedListNode <span class="cov8" title="1">{
        if head == nil </span><span class="cov0" title="0">{
                return head
        }</span>

        <span class="cov8" title="1">sentinel := &amp;structures.LinkedListNode{
                Next: head,
        }
        current, prev := sentinel.Next, sentinel

        for current != nil </span><span class="cov8" title="1">{
                next := current.Next

                if next != nil </span><span class="cov8" title="1">{
                        // 从链表中删除待反转节点
                        current.Next = next.Next
                        // 待反转节点指向被反转节点
                        next.Next = current
                        // 待反转节点重新接入到链表中
                        prev.Next = next
                }</span>

                <span class="cov8" title="1">prev = current
                current = current.Next</span>
        }

        <span class="cov8" title="1">return sentinel.Next</span>
}
</pre>
		
		<pre class="file" id="file98" style="display: none">package medium260

func singleNumber(nums []int) []int <span class="cov8" title="1">{
        var ans int
        // 结束下文这个迭代后，ans 此时为两个唯一值的异或结果值
        for _, num := range nums </span><span class="cov8" title="1">{
                ans ^= num
        }</span>
        // 定一个非 0 位作为分组标志
        <span class="cov8" title="1">div := 1
        for (div &amp; ans) == 0 </span><span class="cov0" title="0">{
                div &lt;&lt;= 1
        }</span>
        // 另外一种找到最低非 0 位的方式是，按位非后与原值进行按位与操作
        // div := ans &amp; (-ans)
        <span class="cov8" title="1">var a, b int
        // 分组异或，分别在两个部分异或，进而得到在子数组中的唯一值
        for _, num := range nums </span><span class="cov8" title="1">{
                if (div &amp; num) == 0 </span><span class="cov8" title="1">{
                        a ^= num
                }</span> else<span class="cov8" title="1"> {
                        b ^= num
                }</span>
        }

        // 综合来看，此法通过分治的思维将问题降维至两个子数组中的唯一值问题

        <span class="cov8" title="1">return []int{a, b}</span>
}
</pre>
		
		<pre class="file" id="file99" style="display: none">package medium3

// LengthOfLongestSubstring is used to find longest substring without repeating characters
func LengthOfLongestSubstring(s string) int <span class="cov8" title="1">{
        left, right, answer := 0, 0, 0
        windowMap := map[byte]int{}

        for right &lt; len(s) </span><span class="cov8" title="1">{
                current := s[right]
                right++
                windowMap[current]++

                // 当当前字母频率大于 1 表示存在重复字符，那么缩小窗口
                for windowMap[current] &gt; 1 </span><span class="cov8" title="1">{
                        deleted := s[left]
                        left++
                        windowMap[deleted]--
                }</span>
                <span class="cov8" title="1">answer = max(answer, right-left)</span>
        }

        <span class="cov8" title="1">return answer</span>
}

func max(a, b int) int <span class="cov8" title="1">{
        if a &gt; b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}
</pre>
		
		<pre class="file" id="file100" style="display: none">package medium328

import structures "leetcode-solutions/data-structures"

type node = structures.LinkedListNode

func oddEvenList(head *node) *node <span class="cov8" title="1">{
        if head == nil </span><span class="cov0" title="0">{
                return head
        }</span>

        <span class="cov8" title="1">evenHead := head.Next
        odd := head
        even := evenHead
        for even != nil &amp;&amp; even.Next != nil </span><span class="cov8" title="1">{
                odd.Next = even.Next
                odd = odd.Next
                even.Next = odd.Next
                even = even.Next
        }</span>
        <span class="cov8" title="1">odd.Next = evenHead
        return head</span>
}
</pre>
		
		<pre class="file" id="file101" style="display: none">package medium33

func search(nums []int, target int) int <span class="cov8" title="1">{
        left, right := 0, len(nums)-1

        // 参考 https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/er-fen-fa-python-dai-ma-java-dai-ma-by-liweiwei141/
        for left &lt; right </span><span class="cov8" title="1">{
                // 与题无关，当有边界设置为 left = mid 和 right = mid-1 出现时，需要将 mid 的下
                // 取整调整为上取整，以避免出现死循环，故有 left + ((right-left+1) &gt;&gt; 1)
                // 原因在于如果我们不+1，则是取下整，得到的中点 mid 即为 left，而在
                // [left,right] 区间中只有两个元素时，若再次进入 if/else 分支，由于是闭区间，又会
                // 取 mid 的值并赋给 left，从而使二者变为定值，便进入死循环。
                mid := left + ((right - left + 1) &gt;&gt; 1)
                pivot := nums[mid]

                // step1: 首先判断 mid 所在的单调区间，利用单调性进行二分操作
                //        数组最大值
                //           /|
                //          / |
                //         /  |
                // 数组拐点--- | ---数组拐点
                //            |   /
                //            |  /
                //            | /
                //            |/
                //       数组中最小值
                // mid 位于最小值到拐点区间，此时 [mid, right] 一定是有序的
                if pivot &lt; nums[right] </span><span class="cov8" title="1">{
                        if pivot &lt;= target &amp;&amp; target &lt;= nums[right] </span><span class="cov8" title="1">{
                                left = mid // 下一轮区间 [mid, right]
                        }</span> else<span class="cov8" title="1"> {
                                right = mid - 1 // 下一轮区间 [left, mid-1]
                        }</span>
                } else<span class="cov8" title="1"> {
                        // 结合 !(pivot &lt; nums[right]) 条件，mid 此时位于拐点到最大值区间，此时 [left, mid] 一定是有序的。
                        if nums[left] &lt;= target &amp;&amp; target &lt;= nums[mid-1] </span><span class="cov8" title="1">{
                                right = mid - 1 // 下一轮区间 [left, mid-1]
                        }</span> else<span class="cov8" title="1"> {
                                left = mid // 下一轮区间 [mid, right]
                        }</span>

                        // 补充说明：由于中间数上取整，在区间只剩下两个元素的时候，mid 与 right 重合，
                        // 方法逻辑走到 else 分支里。此时恰好 if 这个分支看到的是 left 和 mid - 1 ，用
                        // 到的都是 == 号，等价于判断 nums[left] == target。因此依然可以缩减区间，注意
                        // 这里 if 里面的 nums[left] &lt;= target &amp;&amp; target &lt;= nums[mid - 1] ，
                        // 不可以写成 nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]，如在 [3,1] 这样的
                        // 用例中将出现错误答案

                }
        }

        <span class="cov8" title="1">if nums[left] == target </span><span class="cov8" title="1">{
                return left
        }</span>
        <span class="cov8" title="1">return -1</span>
}

func search0(nums []int, target int) int <span class="cov8" title="1">{
        left, right := 0, len(nums)-1

        for left &lt; right </span><span class="cov8" title="1">{
                mid := left + ((right - left) &gt;&gt; 1)

                // mid 位于最小值到拐点区间，此时 [mid, right] 一定是有序的
                if nums[mid] &lt; nums[right] </span><span class="cov8" title="1">{
                        // 此 if 中保证始终可能有 target 等于 right 边界的比较
                        if nums[mid] &lt; target &amp;&amp; target &lt;= nums[right] </span><span class="cov8" title="1">{
                                left = mid + 1
                        }</span> else<span class="cov8" title="1"> {
                                right = mid
                        }</span>
                } else<span class="cov8" title="1"> {
                        // 结合 !(pivot &lt; nums[right]) 条件，mid 此时位于拐点到最大值区间，此时 [left, mid] 一定是有序的。
                        // 此 if 中保证始终可能有 target 等于 left 边界的比较
                        // 此处有 target &lt;= nums[mid] 判断是因为之前的 if 判断没有覆盖到等于 nums[mid] 的场景
                        if nums[left] &lt;= target &amp;&amp; target &lt;= nums[mid] </span><span class="cov8" title="1">{
                                right = mid
                        }</span> else<span class="cov8" title="1"> {
                                left = mid + 1
                        }</span>
                }
        }

        <span class="cov8" title="1">if nums[left] == target </span><span class="cov8" title="1">{
                return left
        }</span>

        <span class="cov8" title="1">return -1</span>
}
</pre>
		
		<pre class="file" id="file102" style="display: none">package medium338

func countBits(num int) []int <span class="cov8" title="1">{
        var onesCount func(int) int
        onesCount = func(x int) (ones int) </span><span class="cov8" title="1">{
                for x &gt; 0 </span><span class="cov8" title="1">{
                        x &amp;= (x - 1) // 将二进制最右(低位)的 1 变为 0
                        ones++
                }</span>
                <span class="cov8" title="1">return ones</span>
        }

        <span class="cov8" title="1">bits := make([]int, num+1)
        for i := range bits </span><span class="cov8" title="1">{
                bits[i] = onesCount(i)
        }</span>
        <span class="cov8" title="1">return bits</span>
}
</pre>
		
		<pre class="file" id="file103" style="display: none">package medium34

import (
        "sort"
)

func searchRangeON(nums []int, target int) []int <span class="cov8" title="1">{
        first, last := -1, -1
        for i, v := range nums </span><span class="cov8" title="1">{
                if target == v </span><span class="cov8" title="1">{
                        if first == -1 </span><span class="cov8" title="1">{
                                first = i
                        }</span>
                        <span class="cov8" title="1">last = i</span>
                }
        }
        <span class="cov8" title="1">return []int{first, last}</span>
}

func searchRangeOLogNByNativeMethod(nums []int, target int) []int <span class="cov8" title="1">{
        // SearchInts searches for x in a sorted slice of ints and returns the index as specified by Search. The return value is the index to insert x if x is not present (it could be len(a)). The slice must be sorted in ascending order.
        first := sort.SearchInts(nums, target)
        if first == len(nums) || nums[first] != target </span><span class="cov8" title="1">{
                return []int{-1, -1}
        }</span>
        <span class="cov8" title="1">last := sort.SearchInts(nums, target+1) - 1
        return []int{first, last}</span>
}

func searchRangeOLogN(nums []int, target int) []int <span class="cov8" title="1">{
        // lower 表示是否需要尽可能的查找低位
        var binarySearch = func(nums []int, target int, lower bool) (ans int) </span><span class="cov8" title="1">{
                low, high := 0, len(nums)-1
                ans = len(nums)
                for low &lt;= high </span><span class="cov8" title="1">{
                        mid := low + (high-low)/2
                        if nums[mid] &gt; target || (lower &amp;&amp; (nums[mid] &gt;= target)) </span><span class="cov8" title="1">{
                                high = mid - 1
                                ans = mid
                        }</span> else<span class="cov8" title="1"> {
                                low = mid + 1
                        }</span>
                }
                <span class="cov8" title="1">return</span>
        }
        <span class="cov8" title="1">first := binarySearch(nums, target, true)
        last := binarySearch(nums, target, false) - 1
        if first &lt;= last &amp;&amp; last &lt; len(nums) &amp;&amp; nums[first] == target &amp;&amp; nums[last] == target </span><span class="cov8" title="1">{
                return []int{first, last}
        }</span>
        <span class="cov8" title="1">return []int{-1, -1}</span>
}

func searchRangeOLogN0(nums []int, target int) []int <span class="cov8" title="1">{
        var findStartPos = func(nums []int, target int) int </span><span class="cov8" title="1">{
                left, right := 0, len(nums)-1
                for left &lt; right </span><span class="cov8" title="1">{
                        mid := left + ((right - left) &gt;&gt; 1)
                        if nums[mid] &lt; target </span><span class="cov8" title="1">{
                                left = mid + 1
                        }</span> else<span class="cov8" title="1"> {
                                right = mid
                        }</span>
                }

                <span class="cov8" title="1">if nums[left] == target </span><span class="cov8" title="1">{
                        return left
                }</span>
                <span class="cov8" title="1">return -1</span>
        }
        <span class="cov8" title="1">var findEndPos = func(nums []int, target int) int </span><span class="cov8" title="1">{
                left, right := 0, len(nums)-1
                for left &lt; right </span><span class="cov8" title="1">{
                        mid := left + ((right - left + 1) &gt;&gt; 1)
                        if nums[mid] &gt; target </span><span class="cov8" title="1">{
                                right = mid - 1
                        }</span> else<span class="cov8" title="1"> {
                                left = mid
                        }</span>
                }

                <span class="cov8" title="1">return left</span>
        }

        <span class="cov8" title="1">if len(nums) &lt; 1 </span><span class="cov8" title="1">{
                return []int{-1, -1}
        }</span>

        <span class="cov8" title="1">start, end := findStartPos(nums, target), findEndPos(nums, target)

        if start &gt; -1 &amp;&amp;
                start &lt;= end &amp;&amp;
                nums[start] == target </span><span class="cov8" title="1">{
                return []int{start, end}
        }</span>

        <span class="cov8" title="1">return []int{-1, -1}</span>
}
</pre>
		
		<pre class="file" id="file104" style="display: none">package medium39

func combinationSum(candidates []int, target int) (answer [][]int) <span class="cov8" title="1">{
        comb := []int{}
        var dfs func(int, int)
        dfs = func(target, index int) </span><span class="cov8" title="1">{
                // break up dfs recursion when we reach tail node
                if index == len(candidates) </span><span class="cov8" title="1">{
                        return
                }</span>
                // break up dfs recursion and save result when we reach target sum
                <span class="cov8" title="1">if target == 0 </span><span class="cov8" title="1">{
                        answer = append(answer, append([]int(nil), comb...))
                        return
                }</span>
                /*
                        We have all 2 decisions, use current element or not.
                */
                // make decision 1, skip `index` elements
                <span class="cov8" title="1">dfs(target, index+1)
                // make decision 2, use `index`th element
                if target-candidates[index] &gt;= 0 </span><span class="cov8" title="1">{
                        comb = append(comb, candidates[index])
                        dfs(target-candidates[index], index)
                        // remove element when we have made decision(because we use the only one variable to store all possible results)
                        comb = comb[:len(comb)-1]
                }</span>
        }
        // activate dfs to find all results
        <span class="cov8" title="1">dfs(target, 0)
        return</span>
}

func combinationSum1(candidates []int, target int) (answer [][]int) <span class="cov8" title="1">{
        var dfs func(int, int, *[]int)
        dfs = func(target, index int, combine *[]int) </span><span class="cov8" title="1">{
                if index &gt;= len(candidates) </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">if target == 0 </span><span class="cov8" title="1">{
                        answer = append(answer, append([]int(nil), *combine...))
                        return
                }</span>
                <span class="cov8" title="1">dfs(target, index+1, combine)
                if target-candidates[index] &gt;= 0 </span><span class="cov8" title="1">{
                        // we should use a new slice to store next result when we are using current node.
                        comb := append(*combine, candidates[index])
                        dfs(target-candidates[index], index, &amp;comb)
                }</span>
        }
        <span class="cov8" title="1">dfs(target, 0, &amp;[]int{})
        return</span>
}

func combinationSum2(candidates []int, target int) (ans [][]int) <span class="cov8" title="1">{
        set := []int{}
        n := len(candidates)
        var sum int
        var dfs func(int)
        dfs = func(current int) </span><span class="cov8" title="1">{
                if sum &gt; target </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">if sum == target </span><span class="cov8" title="1">{
                        ans = append(ans, append([]int(nil), set...))
                        return
                }</span>
                <span class="cov8" title="1">for i := current; i &lt; n; i++ </span><span class="cov8" title="1">{
                        num := candidates[i]
                        set = append(set, num)
                        sum += num
                        dfs(i)
                        set = set[:len(set)-1]
                        sum -= num
                }</span>
        }
        <span class="cov8" title="1">dfs(0)
        return</span>
}
</pre>
		
		<pre class="file" id="file105" style="display: none">package medium406

import "sort"

func reconstructQueue(people [][]int) [][]int <span class="cov8" title="1">{
        sort.Slice(people, func(i, j int) bool </span><span class="cov8" title="1">{
                a, b := people[i], people[j]
                return a[0] &gt; b[0] || (a[0] == b[0] &amp;&amp; a[1] &lt; b[1])
        }</span>)

        <span class="cov8" title="1">var ans [][]int
        for _, person := range people </span><span class="cov8" title="1">{
                i := person[1]
                ans = append(ans[:i], append([][]int{person}, ans[i:]...)...)
        }</span>
        <span class="cov8" title="1">return ans</span>
}
</pre>
		
		<pre class="file" id="file106" style="display: none">package medium43

import "strconv"

func multiply(num1, num2 string) string <span class="cov8" title="1">{
        answer := `0`
        if num1 == `0` || num2 == `0` </span><span class="cov0" title="0">{
                return answer
        }</span>
        <span class="cov8" title="1">m, n := len(num1), len(num2)
        for i := n - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{ // num2[i]
                result, carry := ``, 0
                // 通过初始尾部补零来规避成 10 的倍数操作，可规避溢出隐患
                for j := i + 1; j &lt;= n-1; j++ </span><span class="cov8" title="1">{
                        result += `0`
                }</span>
                <span class="cov8" title="1">y := int(num2[i] - '0')
                for j := m - 1; j &gt;= 0; j-- </span><span class="cov8" title="1">{ // num1[j]
                        x := int(num1[j] - '0')
                        product := x*y + carry
                        carry = product / 10
                        result = strconv.Itoa(product%10) + result
                }</span>

                <span class="cov8" title="1">for ; carry != 0; carry /= 10 </span><span class="cov8" title="1">{
                        result = strconv.Itoa(carry%10) + result
                }</span>

                <span class="cov8" title="1">answer = addStrings(answer, result)</span>
        }

        <span class="cov8" title="1">return answer</span>
}

func addStrings(x, y string) string <span class="cov8" title="1">{
        carry, answer := 0, ``

        for i, j := len(x)-1, len(y)-1; i &gt;= 0 || j &gt;= 0 || carry &gt; 0; i, j = i-1, j-1 </span><span class="cov8" title="1">{
                a, b := 0, 0
                if i &gt;= 0 </span><span class="cov8" title="1">{
                        a = int(x[i] - '0')
                }</span>
                <span class="cov8" title="1">if j &gt;= 0 </span><span class="cov8" title="1">{
                        b = int(y[j] - '0')
                }</span>
                <span class="cov8" title="1">sum := a + b + carry
                carry = sum / 10
                answer = strconv.Itoa(sum%10) + answer</span>
        }

        <span class="cov8" title="1">return answer</span>
}
</pre>
		
		<pre class="file" id="file107" style="display: none">package medium438

/*
        推荐解决 easy 242 有效的字母异位词，来首先解决如何判断存在异位词的问题
*/

// FindAnagram is used to find all anagrams
func FindAnagram(s, p string) []int <span class="cov8" title="1">{
        needsMap, windowMap := map[byte]int{}, map[byte]int{}
        left, right := 0, 0
        answer, validsInWindow := []int{}, 0

        // 构建目标异位词的哈希映射，最大 size 为包含所有 26 个字母，即 26
        for i := range p </span><span class="cov8" title="1">{
                needsMap[p[i]]++
        }</span>

        <span class="cov8" title="1">for right &lt; len(s) </span><span class="cov8" title="1">{
                // 增大窗口
                current := s[right]
                right++
                // 若当前为异位词所包含的字母，那么进入处理
                if _, ok := needsMap[current]; ok </span><span class="cov8" title="1">{
                        windowMap[current]++
                        // 当指定字母频率相等时，计数一次，当 validsInWindow 与异位词的映射大小相同时，
                        // 表示当前窗口存在 p 的异位词
                        if needsMap[current] == windowMap[current] </span><span class="cov8" title="1">{
                                validsInWindow++
                        }</span>
                }

                // 当窗口大于 p 时，开始尝试缩小窗口，并找到异位词
                <span class="cov8" title="1">for (right - left) &gt;= len(p) </span><span class="cov8" title="1">{
                        // 如 easy 242 思路，那么在以下计数相等的情况下，即在窗口中存在异位词
                        if validsInWindow == len(needsMap) </span><span class="cov8" title="1">{
                                answer = append(answer, left)
                        }</span>

                        // 缩小窗口
                        <span class="cov8" title="1">deleted := s[left]
                        left++
                        // 剔除因缩小窗口降低的字母频率
                        if _, ok := needsMap[deleted]; ok </span><span class="cov8" title="1">{
                                if windowMap[deleted] == needsMap[deleted] </span><span class="cov8" title="1">{
                                        validsInWindow--
                                }</span>
                                <span class="cov8" title="1">windowMap[deleted]--</span>
                        }
                }
        }

        <span class="cov8" title="1">return answer</span>
}
</pre>
		
		<pre class="file" id="file108" style="display: none">package medium445

import (
        structures "leetcode-solutions/data-structures"
)

type node = structures.LinkedListNode

func addTwoNumbers(l1 *node, l2 *node) *node <span class="cov8" title="1">{
        sentinel := &amp;node{}
        current, carry := l1, 0
        stack1, stack2 := []*node{}, []*node{}
        for current != nil </span><span class="cov8" title="1">{
                stack1 = append(stack1, current)
                current = current.Next
        }</span>
        <span class="cov8" title="1">current = l2
        for current != nil </span><span class="cov8" title="1">{
                stack2 = append(stack2, current)
                current = current.Next
        }</span>

        <span class="cov8" title="1">for len(stack1) &gt; 0 || len(stack2) &gt; 0 </span><span class="cov8" title="1">{
                a, b := 0, 0
                if len(stack1) &gt; 0 </span><span class="cov8" title="1">{
                        last := len(stack1) - 1
                        a = stack1[last].Val
                        stack1 = stack1[:last]
                }</span>
                <span class="cov8" title="1">if len(stack2) &gt; 0 </span><span class="cov8" title="1">{
                        last := len(stack2) - 1
                        b = stack2[last].Val
                        stack2 = stack2[:last]
                }</span>
                <span class="cov8" title="1">sum := a + b + carry
                carry = sum / 10
                sentinel.Next = &amp;node{Val: sum % 10, Next: sentinel.Next}</span>
        }

        <span class="cov8" title="1">if carry &gt; 0 </span><span class="cov0" title="0">{
                sentinel.Next = &amp;node{Val: carry, Next: sentinel.Next}
        }</span>

        <span class="cov8" title="1">return sentinel.Next</span>
}
</pre>
		
		<pre class="file" id="file109" style="display: none">package medium46

func permute(nums []int) (ans [][]int) <span class="cov8" title="1">{
        var isInSlice func([]int, int) bool
        isInSlice = func(list []int, num int) bool </span><span class="cov8" title="1">{
                for _, item := range list </span><span class="cov8" title="1">{
                        if item == num </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
                <span class="cov8" title="1">return false</span>
        }

        <span class="cov8" title="1">set, n := []int{}, len(nums)
        var dfs func(int)
        dfs = func(current int) </span><span class="cov8" title="1">{
                // 在 backtrack 模板中，首先定义递归退出条件，退出时要将路径添加到结果中
                if current == n </span><span class="cov8" title="1">{
                        ans = append(ans, append([]int(nil), set...))
                        return
                }</span>
                <span class="cov8" title="1">for _, num := range nums </span><span class="cov8" title="1">{
                        // 原始序列不含重复值且求全排列，故无重复值添加
                        if isInSlice(set, num) </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        // 选择当前项
                        <span class="cov8" title="1">set = append(set, num)
                        // 在选择当前项后，进入下一决策
                        dfs(current + 1)
                        // 回溯当前项
                        set = set[:len(set)-1]</span>
                }
        }
        <span class="cov8" title="1">dfs(0)
        return</span>
}
</pre>
		
		<pre class="file" id="file110" style="display: none">package medium48

func rotate(matrix [][]int) <span class="cov8" title="1">{
        n := len(matrix)
        // 上下镜像翻转，即二维数组中顺序和逆序对称交换
        for i := 0; i &lt; n/2; i++ </span><span class="cov8" title="1">{
                matrix[i], matrix[n-1-i] = matrix[n-1-i], matrix[i]
        }</span>

        // 将矩阵转置，即行列互换，表现为对角线翻转
        <span class="cov8" title="1">for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                for j := 0; j &lt; i; j++ </span><span class="cov8" title="1">{
                        matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file111" style="display: none">package medium567

// CheckInclusion is used to test permutation in string
func CheckInclusion(s1, s2 string) bool <span class="cov8" title="1">{
        left, right := 0, 0
        needsMap, windowMap := map[byte]int{}, map[byte]int{}
        validsInWindow := 0

        for i := range s1 </span><span class="cov8" title="1">{
                needsMap[s1[i]]++
        }</span>

        <span class="cov8" title="1">for right &lt; len(s2) </span><span class="cov8" title="1">{
                current := s2[right]
                right++
                if _, ok := needsMap[current]; ok </span><span class="cov8" title="1">{
                        windowMap[current]++
                        if windowMap[current] == needsMap[current] </span><span class="cov8" title="1">{
                                validsInWindow++
                        }</span>
                }

                // window 长度不小于 s1 的长度时，表示 s1 可能是 window 区域的异
                // 位词，即 s1 可能是 s2 的子串排列，故缩小窗口
                <span class="cov8" title="1">for (right - left) &gt;= len(s1) </span><span class="cov8" title="1">{
                        if validsInWindow == len(needsMap) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                        <span class="cov8" title="1">deleted := s2[left]
                        left++
                        if _, ok := needsMap[deleted]; ok </span><span class="cov8" title="1">{
                                if windowMap[deleted] == needsMap[deleted] </span><span class="cov8" title="1">{
                                        validsInWindow--
                                }</span>
                                <span class="cov8" title="1">windowMap[deleted]--</span>
                        }
                }
        }

        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file112" style="display: none">package medium61

import structures "leetcode-solutions/data-structures"

type node = structures.LinkedListNode

func rotateRight(head *node, k int) *node <span class="cov8" title="1">{
        if head == nil || head.Next == nil </span><span class="cov0" title="0">{
                return head
        }</span>

        <span class="cov8" title="1">length := 1
        current := head
        for current.Next != nil </span><span class="cov8" title="1">{
                length++
                current = current.Next
        }</span>

        <span class="cov8" title="1">k = k % length
        current.Next = head
        current = head
        for i := 0; i &lt; length-k-1; i++ </span><span class="cov8" title="1">{
                current = current.Next
        }</span>

        <span class="cov8" title="1">head = current.Next
        current.Next = nil
        return head</span>
}
</pre>
		
		<pre class="file" id="file113" style="display: none">package medium62

func uniquePaths(m, n int) int <span class="cov8" title="1">{
        rows, cols, matrix := n, m, make([][]int, n)

        for i := 0; i &lt; rows; i++ </span><span class="cov8" title="1">{
                matrix[i] = make([]int, cols)
                matrix[i][0] = 1
        }</span>
        <span class="cov8" title="1">for i := 0; i &lt; cols; i++ </span><span class="cov8" title="1">{
                matrix[0][i] = 1
        }</span>

        <span class="cov8" title="1">for i := 1; i &lt; rows; i++ </span><span class="cov8" title="1">{
                for j := 1; j &lt; cols; j++ </span><span class="cov8" title="1">{
                        matrix[i][j] = matrix[i-1][j] + matrix[i][j-1]
                }</span>
        }

        <span class="cov8" title="1">return matrix[n-1][m-1]</span>
}

// 核心思考路径同上，不同之处在于通过滚动数组降低空间复杂度为 O(n)
func uniquePathsByScrollArray(m, n int) int <span class="cov8" title="1">{
        lastRow := make([]int, n, n) // []int{0, 0, 0, ..., 0}
        for i := range lastRow </span><span class="cov8" title="1">{
                lastRow[i] = 1
        }</span>

        <span class="cov8" title="1">for i := 1; i &lt; m; i++ </span><span class="cov8" title="1">{
                for j := 1; j &lt; n; j++ </span><span class="cov8" title="1">{
                        lastRow[j] = lastRow[j-1] + lastRow[j]
                }</span>
        }

        <span class="cov8" title="1">return lastRow[n-1]</span>
}
</pre>
		
		<pre class="file" id="file114" style="display: none">package medium64

func minPathSum(grid [][]int) int <span class="cov8" title="1">{
        if len(grid) &lt; 1 || len(grid[0]) &lt; 1 </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">rows, cols, dp := len(grid), len(grid[0]), make([][]int, len(grid))

        dp[0] = make([]int, cols)
        dp[0][0] = grid[0][0]
        for i := 1; i &lt; rows; i++ </span><span class="cov8" title="1">{
                dp[i] = make([]int, cols)
                // 因为每次只能向下和向右，故有以下赋值
                dp[i][0] = dp[i-1][0] + grid[i][0]
        }</span>

        <span class="cov8" title="1">for i := 1; i &lt; cols; i++ </span><span class="cov8" title="1">{
                // 因为每次只能向下和向右，故有以下赋值
                dp[0][i] = dp[0][i-1] + grid[0][i]
        }</span>

        <span class="cov8" title="1">for i := 1; i &lt; rows; i++ </span><span class="cov8" title="1">{
                for j := 1; j &lt; cols; j++ </span><span class="cov8" title="1">{
                        dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
                }</span>
        }

        <span class="cov8" title="1">return dp[rows-1][cols-1]</span>
}

func min(a, b int) int <span class="cov8" title="1">{
        if a &gt; b </span><span class="cov8" title="1">{
                return b
        }</span>
        <span class="cov8" title="1">return a</span>
}

func minPathSumOptimize(grid [][]int) int <span class="cov8" title="1">{
        if grid == nil || len(grid) &lt; 1 || len(grid[0]) &lt; 1 </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">var min func(int, int) int
        min = func(a, b int) int </span><span class="cov8" title="1">{
                if a &gt; b </span><span class="cov8" title="1">{
                        return b
                }</span>
                <span class="cov8" title="1">return a</span>
        }
        <span class="cov8" title="1">dp := make([]int, len(grid[0]))
        rows, cols := len(grid), len(grid[0])
        dp[0] = grid[0][0]

        for i := 1; i &lt; cols; i++ </span><span class="cov8" title="1">{
                dp[i] = dp[i-1] + grid[0][i]
        }</span>

        <span class="cov8" title="1">for i := 1; i &lt; rows; i++ </span><span class="cov8" title="1">{
                dp[0] += grid[i][0]
                for j := 1; j &lt; cols; j++ </span><span class="cov8" title="1">{
                        dp[j] = min(dp[j-1], dp[j]) + grid[i][j]
                }</span>
        }

        <span class="cov8" title="1">return dp[cols-1]</span>
}
</pre>
		
		<pre class="file" id="file115" style="display: none">package medium662

import (
        structures "leetcode-solutions/data-structures"
)

type node struct {
        val   *structures.BinaryTreeNode
        index int
}

func widthOfBinaryTree(root *structures.BinaryTreeNode) int <span class="cov8" title="1">{
        if root == nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">queue, answer := []node{node{val: root, index: 0}}, 0

        for len(queue) &gt; 0 </span><span class="cov8" title="1">{
                answer = max(1+queue[len(queue)-1].index-queue[0].index, answer)
                levelSize := len(queue)

                for i := 0; i &lt; levelSize; i++ </span><span class="cov8" title="1">{
                        current := shift(&amp;queue)
                        currentNode, index := current.val, current.index

                        if currentNode.Left != nil </span><span class="cov8" title="1">{
                                // 借鉴在 BST 及其相似结构通过顺序存储时，index 节点的左子节点为 2*index,  右子节点为 2*index + 1
                                queue = append(queue, node{val: currentNode.Left, index: 2 * index})
                        }</span>
                        <span class="cov8" title="1">if currentNode.Right != nil </span><span class="cov8" title="1">{
                                queue = append(queue, node{val: currentNode.Right, index: 2*index + 1})
                        }</span>
                }
        }

        <span class="cov8" title="1">return answer</span>
}

func max(a, b int) int <span class="cov8" title="1">{
        if a &gt; b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}

func shift(nodes *[]node) node <span class="cov8" title="1">{
        deleted := (*nodes)[0]
        *nodes = (*nodes)[1:]
        return deleted
}</span>
</pre>
		
		<pre class="file" id="file116" style="display: none">package medium677

// MapSum defines a kind of trie tree node
type MapSum struct {
        val  int
        next map[rune]*MapSum
}

// Constructor is used to initialize a MapSum instance
func Constructor() MapSum <span class="cov8" title="1">{
        return MapSum{next: make(map[rune]*MapSum)}
}</span>

// Insert is used to insert key-value pair
func (root *MapSum) Insert(key string, val int) <span class="cov8" title="1">{
        for _, char := range key </span><span class="cov8" title="1">{
                if _, ok := root.next[char]; !ok </span><span class="cov8" title="1">{
                        children := Constructor()
                        root.next[char] = &amp;children
                }</span>
                <span class="cov8" title="1">root = root.next[char]</span>
        }
        <span class="cov8" title="1">root.val = val</span>
}

// Sum is used to calculate all prefix string sum
func (root *MapSum) Sum(prefix string) int <span class="cov8" title="1">{
        for _, char := range prefix </span><span class="cov8" title="1">{
                if _, ok := root.next[char]; !ok </span><span class="cov0" title="0">{
                        return 0
                }</span>
                <span class="cov8" title="1">root = root.next[char]</span>
        }
        // 此时 node 为以 prefix 为前缀的 trie tree，那么求 node 的所有子节点的 val 之和（通过 dfs）
        <span class="cov8" title="1">return dfs(root)</span>
}

func dfs(s *MapSum) (res int) <span class="cov8" title="1">{
        res += s.val
        for _, v := range s.next </span><span class="cov8" title="1">{
                res += dfs(v)
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file117" style="display: none">package medium701

import (
        structures "leetcode-solutions/data-structures"
)

type node = structures.BinaryTreeNode

func insertIntoBST(root *node, val int) *node <span class="cov8" title="1">{
        if root == nil </span><span class="cov8" title="1">{
                return &amp;node{Val: val}
        }</span>
        <span class="cov8" title="1">if root.Val &gt; val </span><span class="cov8" title="1">{
                root.Left = insertIntoBST(root.Left, val)
        }</span> else<span class="cov8" title="1"> if root.Val &lt; val </span><span class="cov8" title="1">{
                root.Right = insertIntoBST(root.Right, val)
        }</span>
        <span class="cov8" title="1">return root</span>
}
</pre>
		
		<pre class="file" id="file118" style="display: none">package medium707

// ListNode defines a node from singly linked list
type ListNode struct {
        Val  int
        Next *ListNode
}

// LinkedList defines a singly linked list with size
type LinkedList struct {
        size int
        head *ListNode
}

// CreateLinkedList is used to create a singly linked list
func CreateLinkedList() LinkedList <span class="cov8" title="1">{
        /*
                KEY: singly linked list should include a sentinel node for simplify head deletion
        */
        return LinkedList{size: 0, head: &amp;ListNode{}}
}</span>

// Get is used to get a specific node
func (list *LinkedList) Get(index int) int <span class="cov8" title="1">{
        if index &gt; (list.size - 1) </span><span class="cov0" title="0">{
                return -1
        }</span>
        <span class="cov8" title="1">current := list.head.Next
        for i := 0; i &lt; index; i++ </span><span class="cov8" title="1">{
                current = current.Next
        }</span>
        <span class="cov8" title="1">return current.Val</span>
}

// AddAtHead is used to add a node from head
func (list *LinkedList) AddAtHead(val int) <span class="cov8" title="1">{
        current := &amp;ListNode{Val: val, Next: list.head.Next}
        list.head.Next = current
        list.size++
}</span>

// AddAtTail is used to add a node from tail
func (list *LinkedList) AddAtTail(val int) <span class="cov8" title="1">{
        current := list.head
        for current.Next != nil </span><span class="cov8" title="1">{
                current = current.Next
        }</span>
        <span class="cov8" title="1">current.Next = &amp;ListNode{Val: val}
        list.size++</span>
}

// AddAtIndex is used to add node based on index
func (list *LinkedList) AddAtIndex(index, val int) <span class="cov8" title="1">{
        if index == list.size </span><span class="cov0" title="0">{
                list.AddAtTail(val)
                return
        }</span>
        // ignore oversize
        <span class="cov8" title="1">if index &gt; list.size </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if index &lt; 0 </span><span class="cov0" title="0">{
                list.AddAtHead(val)
                return
        }</span>

        <span class="cov8" title="1">current := list.head
        for i := 0; i &lt; index; i++ </span><span class="cov8" title="1">{
                current = current.Next
        }</span>
        <span class="cov8" title="1">current.Next = &amp;ListNode{Val: val, Next: current.Next}
        list.size++</span>
}

// DeleteAtIndex is used to delete a node based on index
func (list *LinkedList) DeleteAtIndex(index int) <span class="cov8" title="1">{
        if index &lt; 0 || (index &gt;= list.size) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">current := list.head
        for i := 0; i &lt; index; i++ </span><span class="cov8" title="1">{
                current = current.Next
        }</span>
        <span class="cov8" title="1">current.Next = current.Next.Next
        list.size--</span>
}
</pre>
		
		<pre class="file" id="file119" style="display: none">package medium75

import "sort"

const (
        red = iota
        white
        blue
)

func sortColors0(nums []int) <span class="cov8" title="1">{
        sort.Ints(nums)
}</span>

// Option 1, singly pointer
func sortColors1(nums []int) <span class="cov8" title="1">{
        swapColors := func(colors []int, target int) (countTarget int) </span><span class="cov8" title="1">{
                for i, color := range colors </span><span class="cov8" title="1">{
                        if color == target </span><span class="cov8" title="1">{
                                colors[i], colors[countTarget] = colors[countTarget], colors[i]
                                countTarget++
                        }</span>
                }
                <span class="cov8" title="1">return</span>
        }
        // 一次遍历，将所有 0 前置
        <span class="cov8" title="1">count0 := swapColors(nums, red)
        // 一次遍历，将所有 1 前置，但排在所有 0 之后
        swapColors(nums[count0:], white)</span>
}

// Option ,2, two pointers
func sortColors2(nums []int) <span class="cov8" title="1">{
        p0, p1 := 0, 0
        for i, color := range nums </span><span class="cov8" title="1">{
                if color == red </span><span class="cov8" title="1">{
                        nums[i], nums[p0] = nums[p0], nums[i]
                        if p0 &lt; p1 </span><span class="cov8" title="1">{
                                nums[i], nums[p1] = nums[p1], nums[i]
                        }</span>
                        <span class="cov8" title="1">p0++
                        p1++</span>
                } else<span class="cov8" title="1"> if color == white </span><span class="cov8" title="1">{
                        nums[i], nums[p1] = nums[p1], nums[i]
                        p1++
                }</span>
        }
}

func sortColors3(nums []int) <span class="cov8" title="1">{
        p0, p2 := 0, len(nums)-1
        for i := 0; i &lt;= p2; i++ </span><span class="cov8" title="1">{
                for ; i &lt;= p2 &amp;&amp; nums[i] == blue; p2-- </span><span class="cov8" title="1">{
                        nums[i], nums[p2] = nums[p2], nums[i]
                }</span>
                <span class="cov8" title="1">if nums[i] == red </span><span class="cov8" title="1">{
                        nums[i], nums[p0] = nums[p0], nums[i]
                        p0++
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file120" style="display: none">package medium767

import (
        "container/heap"
        "sort"
)

var counts [26]int

// 结构体中的匿名字段，由类型名取该字段值，如下使用 `IntSlice` 取值
// https://stackoverflow.com/questions/28014591/nameless-fields-in-go-structs
type hp struct{ sort.IntSlice }

func (h hp) Less(i, j int) bool <span class="cov8" title="1">{
        return counts[h.IntSlice[i]] &gt; counts[h.IntSlice[j]]
}</span>
func (h *hp) Push(v interface{}) <span class="cov8" title="1">{
        h.IntSlice = append(h.IntSlice, v.(int))
}</span>
func (h *hp) Pop() interface{} <span class="cov8" title="1">{
        a := h.IntSlice
        deleted := a[len(a)-1]
        h.IntSlice = h.IntSlice[:len(a)-1]
        return deleted
}</span>
func (h *hp) push(v int) <span class="cov8" title="1">{
        heap.Push(h, v)
}</span>
func (h *hp) pop() int <span class="cov8" title="1">{
        return heap.Pop(h).(int)
}</span>

func reorganizeString(s string) string <span class="cov8" title="1">{
        n := len(s)
        if n &lt;= 1 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">counts = [26]int{}
        // create counts
        var maxCounts int
        for _, ch := range s </span><span class="cov8" title="1">{
                ch -= 'a'
                counts[ch]++
                if maxCounts &lt; counts[ch] </span><span class="cov8" title="1">{
                        maxCounts = counts[ch]
                }</span>
        }

        <span class="cov8" title="1">if maxCounts &gt; (n+1)/2 </span><span class="cov0" title="0">{
                return ""
        }</span>

        // init heap
        <span class="cov8" title="1">h := &amp;hp{}
        for i, count := range counts[:] </span><span class="cov8" title="1">{
                if count &gt; 0 </span><span class="cov8" title="1">{
                        h.IntSlice = append(h.IntSlice, i)
                }</span>
        }
        <span class="cov8" title="1">heap.Init(h)

        // construct char code slice
        ans := make([]byte, 0, n)
        for len(h.IntSlice) &gt; 1 </span><span class="cov8" title="1">{
                i, j := h.pop(), h.pop()
                ans = append(ans, byte('a'+i), byte('a'+j))
                if counts[i]--; counts[i] &gt; 0 </span><span class="cov8" title="1">{
                        h.push(i)
                }</span>
                <span class="cov8" title="1">if counts[j]--; counts[j] &gt; 0 </span><span class="cov0" title="0">{
                        h.push(j)
                }</span>
        }
        <span class="cov8" title="1">if len(h.IntSlice) &gt; 0 </span><span class="cov8" title="1">{
                ans = append(ans, byte('a'+h.IntSlice[0]))
        }</span>
        <span class="cov8" title="1">return string(ans)</span>
}
</pre>
		
		<pre class="file" id="file121" style="display: none">package medium78

/*
        思路：
                1. 考虑在 An 项中，只有两种结果，在子即中和不在子集中，那么可用二进制表示是否在子集中。那么每个子集可对应一个长度为 n(n 为源数组的长度) 的 01 序列
                2. 那么在 m 个数位中，每个数位有两种可能，那么总共有 2 的 m 次方种可能(2 * 2 * 2 ... * 2)，那么可归纳出在 n 长度的源数组种，01 序列表示的数的范围在 0 到 2 的 n 次方减一
*/
func subsets0(nums []int) (answer [][]int) <span class="cov8" title="1">{
        n := len(nums)
        // m &lt;&lt; n 表示 m 乘以 2 的 n 次方
        // 01 序列表示的数的范围在 0 ~ 2 的 n 次方减一，那么逐个迭代得到其中一个子集
        for mask := 0; mask &lt; (1 &lt;&lt; n); mask++ </span><span class="cov8" title="1">{
                set := []int(nil) // 使用 nil 切片而非空切片
                for i, v := range nums </span><span class="cov8" title="1">{
                        // m &gt;&gt; n 表示 m 除以 2 的 n 次方

                        // 以下表示 mask 除以 2 的 i 次方，并与 1 做按位与操作
                        // if mask&gt;&gt;i&amp;1 &gt; 0 {
                        //         set = append(set, v)
                        // }

                        /*
                                以下表示 mask 与 2 的 i 次方执行按位与操作，实际意义在于当位操作结果为 0 时，表示二者各个数位没有同为 1 的项，反之二者存在同为 1 的项，即存在交集

                                1. 1 &lt;&lt; i 恒定返回一个二进制低位为 0 的数
                                2. 基于 1 那么 mask &amp; (1 &lt;&lt; i) 总是返回一个 2 的某次幂或 0
                        */
                        if (mask &amp; (1 &lt;&lt; i)) != 0 </span><span class="cov8" title="1">{
                                set = append(set, v)
                        }</span>
                }
                <span class="cov8" title="1">answer = append(answer, append([]int(nil), set...))</span>
        }
        <span class="cov8" title="1">return</span>
}

func subsets1(nums []int) (answer [][]int) <span class="cov8" title="1">{
        set := []int{}
        var dfs func(int)
        dfs = func(current int) </span><span class="cov8" title="1">{
                if current == len(nums) </span><span class="cov8" title="1">{
                        answer = append(answer, append([]int(nil), set...))
                        return
                }</span>
                // 选择当前项，并步进到下一项
                <span class="cov8" title="1">set = append(set, nums[current])
                dfs(current + 1)
                // 不选择当前项，并步进到下一项
                set = set[:len(set)-1]
                dfs(current + 1)</span>
        }
        <span class="cov8" title="1">dfs(0)
        return</span>
}

func subsets2(nums []int) (ans [][]int) <span class="cov8" title="1">{
        n := len(nums)
        var dfs func([]int, int)
        dfs = func(set []int, current int) </span><span class="cov8" title="1">{
                ans = append(ans, append([]int(nil), set...))
                for i := current; i &lt; n; i++ </span><span class="cov8" title="1">{
                        set = append(set, nums[i])
                        dfs(set, i+1)
                        set = set[:len(set)-1]
                }</span>
        }
        <span class="cov8" title="1">dfs([]int{}, 0)
        return</span>
}
</pre>
		
		<pre class="file" id="file122" style="display: none">package medium81

func search(nums []int, target int) bool <span class="cov8" title="1">{
        left, right := 0, len(nums)-1
        for left &lt; right </span><span class="cov8" title="1">{
                mid := left + ((right - left + 1) &gt;&gt; 1)

                if nums[mid] &lt; nums[right] </span><span class="cov8" title="1">{
                        if nums[mid] &lt;= target &amp;&amp; target &lt;= nums[right] </span><span class="cov8" title="1">{
                                left = mid
                        }</span> else<span class="cov8" title="1"> {
                                right = mid - 1
                        }</span>
                } else<span class="cov8" title="1"> if nums[mid] &gt; nums[right] </span><span class="cov0" title="0">{
                        if nums[left] &lt;= target &amp;&amp; target &lt; nums[mid] </span><span class="cov0" title="0">{
                                right = mid - 1
                        }</span> else<span class="cov0" title="0"> {
                                left = mid
                        }</span>
                        // 比 medium-33 多了一个 else 分支
                } else<span class="cov8" title="1"> {
                        if nums[right] == target </span><span class="cov8" title="1">{
                                return true
                        }</span>
                        <span class="cov8" title="1">right--</span>
                }
        }

        <span class="cov8" title="1">return nums[left] == target</span>
}

func search0(nums []int, target int) bool <span class="cov8" title="1">{
        left, right := 0, len(nums)-1

        for left &lt; right </span><span class="cov8" title="1">{
                mid := left + ((right - left) &gt;&gt; 1)

                if nums[mid] &lt; nums[right] </span><span class="cov8" title="1">{
                        if nums[mid] &lt; target &amp;&amp; target &lt;= nums[right] </span><span class="cov8" title="1">{
                                left = mid + 1
                        }</span> else<span class="cov8" title="1"> {
                                right = mid
                        }</span>
                } else<span class="cov8" title="1"> if nums[mid] &gt; nums[right] </span><span class="cov8" title="1">{
                        if nums[left] &lt;= target &amp;&amp; target &lt;= nums[mid] </span><span class="cov8" title="1">{
                                right = mid
                        }</span> else<span class="cov8" title="1"> {
                                left = mid + 1
                        }</span>
                        // 比 medium-33 多了一个 else 分支
                } else<span class="cov8" title="1"> {
                        if nums[right] == target </span><span class="cov0" title="0">{
                                return true
                        }</span>
                        <span class="cov8" title="1">right--</span>
                }
        }

        <span class="cov8" title="1">return nums[left] == target</span>
}
</pre>
		
		<pre class="file" id="file123" style="display: none">package medium82

import (
        structures "leetcode-solutions/data-structures"
)

func deleteDuplicated(head *structures.LinkedListNode) *structures.LinkedListNode <span class="cov8" title="1">{
        if head == nil </span><span class="cov0" title="0">{
                return head
        }</span>

        <span class="cov8" title="1">sentinel := &amp;structures.LinkedListNode{
                Val:  -1,
                Next: head,
        }
        current := sentinel

        for current.Next != nil &amp;&amp; current.Next.Next != nil </span><span class="cov8" title="1">{
                if current.Next.Val == current.Next.Next.Val </span><span class="cov8" title="1">{
                        // 直到下一项不等于下一项的下一项时
                        now := current.Next
                        for now.Next != nil &amp;&amp; now.Val == now.Next.Val </span><span class="cov8" title="1">{
                                now = now.Next
                        }</span>
                        <span class="cov8" title="1">current.Next = now.Next</span>
                } else<span class="cov8" title="1"> {
                        current = current.Next
                }</span>
        }

        <span class="cov8" title="1">return sentinel.Next</span>
}
</pre>
		
		<pre class="file" id="file124" style="display: none">package medium86

import structures "leetcode-solutions/data-structures"

type node = structures.LinkedListNode

func partition(head *node, x int) *node <span class="cov8" title="1">{
        if head == nil </span><span class="cov0" title="0">{
                return head
        }</span>

        <span class="cov8" title="1">lessHead, greatHead := &amp;node{}, &amp;node{}
        less, great := lessHead, greatHead

        current := head
        for current != nil </span><span class="cov8" title="1">{
                if current.Val &lt; x </span><span class="cov8" title="1">{
                        less.Next = current
                        less = less.Next
                }</span> else<span class="cov8" title="1"> {
                        great.Next = current
                        great = great.Next
                }</span>
                <span class="cov8" title="1">current = current.Next</span>
        }
        <span class="cov8" title="1">less.Next = greatHead.Next
        great.Next = nil
        return lessHead.Next</span>
}
</pre>
		
		<pre class="file" id="file125" style="display: none">package medium889

import (
        structures "leetcode-solutions/data-structures"
)

type node = structures.BinaryTreeNode

func constructFromPrePost(pre, post []int) *node <span class="cov8" title="1">{
        if len(pre) &lt; 1 || len(post) &lt; 1 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">val := pre[0]
        root := &amp;node{Val: val}
        if len(pre) == 1 </span><span class="cov8" title="1">{
                return root
        }</span>
        <span class="cov8" title="1">var i int
        for i = range post </span><span class="cov8" title="1">{
                if post[i] == pre[1] </span><span class="cov8" title="1">{
                        i++
                        break</span>
                }
        }
        <span class="cov8" title="1">root.Left = constructFromPrePost(pre[1:i+1], post[:i])
        root.Right = constructFromPrePost(pre[i+1:], post[i:len(post)-1])
        return root</span>
}
</pre>
		
		<pre class="file" id="file126" style="display: none">package medium90

import "sort"

func subsetWithDup(nums []int) (ans [][]int) <span class="cov8" title="1">{
        sort.Ints(nums)
        n := len(nums)
        var dfs func([]int, int)
        dfs = func(set []int, current int) </span><span class="cov8" title="1">{
                ans = append(ans, append([]int(nil), set...))
                for i := current; i &lt; n; i++ </span><span class="cov8" title="1">{
                        if i &gt; current &amp;&amp; nums[i] == nums[i-1] </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">set = append(set, nums[i])
                        dfs(set, i+1)
                        set = set[:len(set)-1]</span>
                }
        }
        <span class="cov8" title="1">dfs([]int{}, 0)
        return</span>
}
</pre>
		
		<pre class="file" id="file127" style="display: none">package medium912

func sortArray(nums []int) []int <span class="cov8" title="1">{
        var swap func([]int, int, int) = func(nums []int, a, b int) </span><span class="cov8" title="1">{
                nums[a], nums[b] = nums[b], nums[a]
        }</span>

        <span class="cov8" title="1">var partition func([]int, int, int) int = func(nums []int, start, end int) int </span><span class="cov8" title="1">{
                pivotIndex := start + ((end - start) &gt;&gt; 1)
                pivot := nums[pivotIndex]
                swap(nums, pivotIndex, end)
                lowIndex := start
                for i := start; i &lt; end; i++ </span><span class="cov8" title="1">{
                        if nums[i] &lt; pivot </span><span class="cov8" title="1">{
                                swap(nums, i, lowIndex)
                                lowIndex++
                        }</span>
                }
                <span class="cov8" title="1">swap(nums, lowIndex, end)
                return lowIndex</span>
        }

        <span class="cov8" title="1">var sort func([]int, int, int)
        sort = func(nums []int, start, end int) </span><span class="cov8" title="1">{
                if start &gt;= end </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">index := partition(nums, start, end)
                sort(nums, start, index-1)
                sort(nums, index+1, end)</span>
        }

        <span class="cov8" title="1">sort(nums, 0, len(nums)-1)
        return nums</span>
}
</pre>
		
		<pre class="file" id="file128" style="display: none">package medium92

import structures "leetcode-solutions/data-structures"

type node = structures.LinkedListNode

func reverseBetween(head *node, m, n int) *node <span class="cov8" title="1">{
        if head == nil </span><span class="cov8" title="1">{
                return head
        }</span>
        <span class="cov8" title="1">sentinel := &amp;node{Next: head}

        prev := sentinel
        for i := 0; i &lt; m-1; i++ </span><span class="cov8" title="1">{
                prev = prev.Next
        }</span>
        <span class="cov8" title="1">current := prev.Next
        // 头插法反转链表部分区间
        for i := m; i &lt; n; i++ </span><span class="cov8" title="1">{
                next := current.Next
                current.Next = next.Next
                next.Next = prev.Next
                prev.Next = next
        }</span>

        <span class="cov8" title="1">return sentinel.Next</span>
}
</pre>
		
		<pre class="file" id="file129" style="display: none">package solution

import (
        structures "leetcode-solutions/data-structures"
)

// IterativeInOrderTraversal is medium 94 solution
func IterativeInOrderTraversal(root *structures.BinaryTreeNode) []int <span class="cov8" title="1">{
        stack := []*structures.BinaryTreeNode{}
        answer := []int{}

        if root == nil </span><span class="cov0" title="0">{
                return answer
        }</span>

        <span class="cov8" title="1">current := root
        for current != nil || len(stack) &gt; 0 </span><span class="cov8" title="1">{
                for current != nil </span><span class="cov8" title="1">{
                        stack = append(stack, current)
                        current = current.Left
                }</span>
                <span class="cov8" title="1">latest := len(stack) - 1
                current = stack[latest]
                stack = stack[:latest]
                // type assertion
                // https://tour.golang.org/methods/15
                answer = append(answer, current.Val)
                current = current.Right</span>
        }

        <span class="cov8" title="1">return answer</span>
}
</pre>
		
		<pre class="file" id="file130" style="display: none">package solution

import structures "leetcode-solutions/data-structures"

// RecursiveInOrderTraversal is medium 94 solution
func RecursiveInOrderTraversal(root *structures.BinaryTreeNode) []int <span class="cov8" title="1">{
        answer := []int{}
        traversal(root, &amp;answer)
        return answer
}</span>

func traversal(root *structures.BinaryTreeNode, answer *[]int) <span class="cov8" title="1">{
        if root == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">traversal(root.Left, answer)
        // type assertion
        // https://tour.golang.org/methods/15
        *answer = append(*answer, root.Val)
        traversal(root.Right, answer)</span>
}
</pre>
		
		<pre class="file" id="file131" style="display: none">package medium96

func numTrees(n int) int <span class="cov8" title="1">{
        num := make([]int, n+1)
        num[0], num[1] = 1, 1
        for i := 2; i &lt;= n; i++ </span><span class="cov8" title="1">{
                for j := 1; j &lt;= i; j++ </span><span class="cov8" title="1">{
                        num[i] += num[j-1] * num[i-j]
                }</span>
        }
        <span class="cov8" title="1">return num[n]</span>
}
</pre>
		
		<pre class="file" id="file132" style="display: none">package medium973

import (
        "container/heap"
        "sort"
)

func kClosest(points [][]int, K int) [][]int <span class="cov8" title="1">{
        sort.Slice(points, func(a, b int) bool </span><span class="cov8" title="1">{
                // 求解平方根时需要引入 float 类型，故存在误差，但仅求解平方和，即为 int 类型，故不用考虑误差
                spaceA := points[a][0]*points[a][0] + points[a][1]*points[a][1]
                spaceB := points[b][0]*points[b][0] + points[b][1]*points[b][1]
                return spaceA &lt; spaceB
        }</span>)

        <span class="cov8" title="1">return points[:K]</span>
}

type point struct {
        distance     int
        coordination []int
}

type pq []point

func (q *pq) Len() int             <span class="cov8" title="1">{ return len(*q) }</span>
func (q *pq) Less(i, j int) bool   <span class="cov8" title="1">{ return (*q)[i].distance &gt; (*q)[j].distance }</span>
func (q *pq) Swap(i, j int)        <span class="cov8" title="1">{ (*q)[i], (*q)[j] = (*q)[j], (*q)[i] }</span>
func (q *pq) Push(val interface{}) <span class="cov0" title="0">{ *q = append(*q, val.(point)) }</span>
func (q *pq) Pop() interface{} <span class="cov0" title="0">{
        queue := *q
        deleted := queue[len(queue)-1]
        *q = queue[:len(queue)-1]
        return deleted
}</span>

func kClosestPQ(points [][]int, k int) (ans [][]int) <span class="cov8" title="1">{
        h := make(pq, k) // 控制大小为 k，即控制二叉堆大小为 k

        // 用第 0~k-1 的 k 个点填充堆容器
        for i, po := range points[:k] </span><span class="cov8" title="1">{
                h[i] = point{po[0]*po[0] + po[1]*po[1], po}
        }</span>

        <span class="cov8" title="1">heap.Init(&amp;h) // O(n) 初始化二叉堆

        for _, po := range points[k:] </span><span class="cov8" title="1">{
                // 与堆顶比较，即 h[0]
                if distance := po[0]*po[0] + po[1]*po[1]; distance &lt; h[0].distance </span><span class="cov8" title="1">{
                        h[0] = point{distance, po}
                        // 在更新索引 i 的值后，通过 Fix 方法重建堆
                        heap.Fix(&amp;h, 0) // 此 if 语句执行效果即堆的插入，执行效率比 pop 后 push 要快
                }</span>
        }

        // 当线性扫描完成时，大小为 k 的二叉堆中留下的点即为最接近原点的 k 个点
        <span class="cov8" title="1">for _, po := range h </span><span class="cov8" title="1">{
                ans = append(ans, po.coordination)
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file133" style="display: none">package medium98

import (
        structures "leetcode-solutions/data-structures"
        "math"
)

type node = structures.BinaryTreeNode

func isValidBSTByIteration(root *node) bool <span class="cov8" title="1">{
        if root == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">stack, current, prevNodeVal := []*node{}, root, math.MinInt32
        for current != nil || len(stack) &gt; 0 </span><span class="cov8" title="1">{
                for current != nil </span><span class="cov8" title="1">{
                        stack = append(stack, current)
                        current = current.Left
                }</span>
                <span class="cov8" title="1">topFrameIndex := len(stack) - 1
                current = stack[topFrameIndex]
                stack = stack[:topFrameIndex]

                if current.Val &lt;= prevNodeVal </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">prevNodeVal = current.Val

                current = current.Right</span>
        }
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file134" style="display: none">package medium98

import "math"

func isValidBSTByRecursion(root *node) bool <span class="cov8" title="1">{
        return traversal(root, math.MinInt32, math.MaxInt32)
}</span>

func traversal(root *node, low, high int) bool <span class="cov8" title="1">{
        if root == nil </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">if (root.Val &lt;= low) || (root.Val &gt;= high) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return traversal(root.Left, low, root.Val) &amp;&amp; traversal(root.Right, root.Val, high)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
